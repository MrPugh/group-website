<papers>

	
<paper>
	<year>Preprints of Accepted Papers</year>
	<content>Michael Codish, Luís Cruz-Filipe, Thorsten Ehlers, Mike Müller, &amp; Peter Schneider-Kamp. &lt;span class=&quot;paper-title&quot;&gt;Sorting networks: to the end and back again&lt;/span&gt;. Journal of Computer and System Sciences.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.jcss.2016.04.004</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paperB.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>New properties of the front and back ends of sorting networks are studied, illustrating their utility when searching for bounds on optimal networks.  Search focuses first on the &amp;ldquo;out-sides&amp;rdquo; of the network and then on the inner part.  Previous works focused on properties of the front end to break symmetries in the search.  The new, out-side-in, properties shed understanding on how sorting networks sort, and facilitate the computation of new bounds on optimality.  We present new, faster, parallel sorting networks for 17&amp;ndash;20 inputs.  For 17 inputs, we show that no sorting network using less layers exists.</abstract>
</paper>
	
<paper>
	<year>Preprints of Accepted Papers</year>
	<content>Luís Cruz-Filipe, Graça Gaspar, Isabel Nunes, &amp; Peter Schneider-Kamp. &lt;span class=&quot;paper-title&quot;&gt;Active Integrity Constraints for General-Purpose Knowledge Bases&lt;/span&gt;. Annals of Mathematics and Artificial Intelligence.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/s10472-018-9577-y</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paperA.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>In the database world, &lt;i&gt;integrity constraints&lt;/i&gt; are essential to guarantee database integrity.  The related problem of database repair deals with finding the best way to change a database so that it satisfies its integrity constraints.  These two topics have been studied intensively since the 1980s.  The formalism of &lt;i&gt;active integrity constraints&lt;/i&gt;, proposed in 2004, aims at addressing them jointly, by providing a syntax whereby a particular subclass of integrity constraints can be specified together with preferred ways to repair inconsistency.&lt;br /&gt;In the last decade, several authors have proposed adaptations of the notion of integrity constraints to other reasoning frameworks than relational databases.  In this article, we extend this line of work in two ways.  First, we target multi-context systems, a general-purpose framework for combining heterogeneous reasoning systems, able to model most other reasoning frameworks, as we demonstrate.  Second, we extend the notions of active integrity constraints and grounded repairs to this generalized setting.  This way of including repair suggestions inside integrity constraints, subject to a validity check, enables us to define simple iterative algorithms to find all possible grounded repairs for an inconsistent multi-context system, avoiding the need to solve complex or undecidable problems.</abstract>
</paper>
	
<paper>
	<year>Preprints of Accepted Papers</year>
	<content>Luís Cruz-Filipe, Fabrizio Montesi, &amp; Marco Peressotti. &lt;span class=&quot;paper-title&quot;&gt;Communications in Choreographies, Revisited&lt;/span&gt;. Proceedings of the Symposium on Applied Computing, SAC 2018, Pau, France, April 9-13, 2018.</content>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1711.10201</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<author>Marco Peressotti</author>
		
	<abstract>Choreographic Programming is a paradigm for developing correct-by-construction concurrent programs, by writing high-level descriptions of the desired communications and then synthesising process implementations automatically. So far, choreographic programming has been explored in the &lt;i&gt;monadic&lt;/i&gt; setting: interaction terms express point-to-point communications of a single value. However, real-world systems often rely on interactions of &lt;i&gt;polyadic&lt;/i&gt; nature, where multiple values are communicated among two or more parties, like multicast, scatter-gather, and atomic exchanges.&lt;br /&gt;We introduce a new model for choreographic programming equipped with a primitive for grouped interactions that subsumes all the above scenarios. Intuitively, grouped interactions can be thought of as being carried out as one single interaction. In practice, they are implemented by processes that carry them out in a concurrent fashion. After formalising the intuitive semantics of grouped interactions, we prove that choreographic programs and their implementations are correct and deadlock-free by construction.</abstract>
</paper>
	

	
<paper>
	<year>2018</year>
	<content>Bart Bogaerts, &amp; Luís Cruz-Filipe. (2018). &lt;span class=&quot;paper-title&quot;&gt;Fixpoint Semantics for Active Integrity Constraints&lt;/span&gt;. Artificial Intelligence, 255, 43–70.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper46.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Active integrity constraints (AICs) constitute a formalism to associate with a database not just the constraints it should adhere to, but also how to fix the database in case one or more of these constraints are violated. The intuitions regarding which repairs are &amp;ldquo;good&amp;rdquo; given such a description are closely related to intuitions that live in various areas of non-monotonic reasoning, such as logic programming and autoepistemic logic.&lt;br /&gt;In this paper, we apply &lt;i&gt;approximation fixpoint theory&lt;/i&gt;, an abstract, algebraic framework designed to unify semantics of non-monotonic logics, to the field of AICs. This results in a new family of semantics for AICs. We study properties of our new semantics and relationships to existing semantics. In particular, we argue that two of the newly defined semantics stand out. &lt;i&gt;Grounded repairs&lt;/i&gt; have a simple definition that is purely based on semantic principles that semantics for AICs should adhere to. And, as we show, they coincide with the intended interpretation of AICs on many examples. The second semantics of interest is the AFT-well-founded semantics: it is a computationally cheap semantics that provides upper- and lower bounds for many other classes of repairs.</abstract>
</paper>
	
<paper>
	<year>2018</year>
	<content>Franco Callegati, Saverio Giallorenzo, Andrea Melis, &amp; Marco Prandini. (2018). &lt;span class=&quot;paper-title&quot;&gt;Cloud-of-Things meets Mobility-as-a-Service: An insider threat perspective&lt;/span&gt;. Computers &amp; Security, 74, 277–295.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/https://doi.org/10.1016/j.cose.2017.10.006</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/cs2017/</link>
	</link>
		
		
	<tag>Smart Cities</tag>
		
	<tag>Internet of Things</tag>
		
	<tag>Security</tag>
		
	<tag>Microservices</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>Mobility-as-a-Service (MaaS) applies the everything-as-a-service paradigm of Cloud Computing to transportation: a MaaS provider offers to its users the dynamic composition of solutions of different travel agencies into a single, consistent interface. Traditionally, transits and data on mobility belong to a scattered plethora of operators. Thus, we argue that the economic model of MaaS is that of federations of providers, each trading its resources to coordinate multi-modal solutions for mobility. Such flexibility comes with many security and privacy concerns, of which insider threat is one of the most prominent. In this paper, we revise and extend previous work where we classified the potential threats of individual operators and markets of federated MaaS providers, proposing appropriate countermeasures to mitigate the problems. In addition, we consider the emerging case of Cloud-of-Things (CoT) for mobility, i.e., networks of ubiquitous, pervasive devices that provide real-time data on objects and people. Automation and pervasiveness of CoT make an additional attack surface for insiders. In an effort to limit such phenomenon, we present an overlay networking architecture, based on gossip protocols, that lets users share information on mobility with each other. A peculiarity of the architecture is that it both constrains the quality and quantity of data obtainable by insiders, optimizing the routing of requests to involve only users that are able to answer them.</abstract>
</paper>
	
<paper>
	<year>2018</year>
	<content>Maurizio Gabbrielli, Saverio Giallorenzo, Ivan Lanese, &amp; Stefano Pio Zingaro. (2018). &lt;span class=&quot;paper-title&quot;&gt;A Language-based Approach for Interoperability of IoT Platforms&lt;/span&gt;. In 51st Hawaii International Conference on System Sciences, HICSS 2018,  Hilton Waikoloa Village, Hawaii, USA, January 3-6, 2018. AIS Electronic Library (AISeL).</content>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/hicss2018/</link>
	</link>
		
	<link>
		<name>website</name>
		<link>http://www.cs.unibo.it/projects/jolie/jiot.html</link>
	</link>
		
		
	<tag>Microservices</tag>
		
	<tag>Internet of Things</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>The Internet of Things (IoT) promotes the communication among heterogeneous entities, from small sensors to Cloud systems. However, this is realized using a wide range of communication media and data protocols, usually incompatible with each other. Thus, IoT systems tend to grow as homogeneous isolated platforms, which hardly interact. To achieve a higher degree of interoperability among disparate IoT platforms, we propose a language-based approach for communication technology integration. We build on the Jolie programming language, which allows programmers to easily make the same logic work over disparate communication stacks in a declarative, dynamic way. Jolie currently supports the main technologies from Service-Oriented Computing, such as TCP/IP, Bluetooth, and RMI at transport level, and HTTP and SOAP at application level. As technical result, we integrate in Jolie the two most adopted protocols for IoT communication, i.e., CoAP and MQTT. In this paper, we report our experience and we present high-level concepts valuable both for the general implementation of interoperable systems and for the development of other language-based solutions.</abstract>
</paper>
	
<paper>
	<year>2018</year>
	<content>Marco Carbone, Fabrizio Montesi, &amp; Carsten Schürmann. (2018). &lt;span class=&quot;paper-title&quot;&gt;Choreographies, logically&lt;/span&gt;. Distributed Computing, 31(1), 51–67.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/s00446-017-0295-1</link>
	</link>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/cms18.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Process Calculi</tag>
		
	<tag>Logic</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.</abstract>
</paper>
	
<paper>
	<year>2018</year>
	<content>Saverio Giallorenzo, Fabrizio Montesi, &amp; Maurizio Gabbrielli. (2018). &lt;span class=&quot;paper-title&quot;&gt;Applied Choreographies&lt;/span&gt;. In Formal Techniques for Distributed Objects, Components, and Systems  - 38th IFIP WG 6.1 International Conference, FORTE 2018, Held  as Part of the 13th International Federated Conference on Distributed  Computing Techniques, DisCoTec 2018, Madrid, Spain, June 18-21, 2018,  Proceedings (pp. 21–40). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-92612-4_2</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/forte2018/</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Session Types</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for distributed programming, where high-level &quot;Alice and Bob&quot; descriptions of communications (choreographies) are used to synthesise correct-by-construction programs. However, implementations of choreographic models use message routing technologies distant from their related theoretical models (e.g., CCS/π channels). This drives implementers to mediate discrepancies with the theory through undocumented, unproven adaptations, weakening the reliability of their implementations. As a solution, we propose the framework of Applied Choreographies (AC). In AC, programmers write choreographies in a language that follows the standard syntax and semantics of previous works. Then, choreographies are compiled to a real-world execution model for Service-Oriented Computing (SOC). To manage the complexity of this task, our compilation happens in three steps, respectively dealing with: implementing name-based communications using the concrete mechanism found in SOC, projecting a choreography to a set of processes, and translating processes to a distributed implementation in terms of services.</abstract>
</paper>
	

	
<paper>
	<year>2017</year>
	<content>Bart Bogaerts, &amp; Luís Cruz-Filipe. (2017). &lt;span class=&quot;paper-title&quot;&gt;Semantics for Active Integrity Constraints Using Approximation Fixpoint Theory&lt;/span&gt;. In C. Sierra (Ed.), Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017, Melbourne, Australia, August 19-25, 2017 (pp. 866–872). ijcai.org.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper42.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Active integrity constraints (AICs) constitute a formalism to associate with a database not just the constraints it should adhere to, but also how to fix the database in case one or more of these constraints are violated. The intuitions regarding which repairs are &amp;ldquo;good&amp;rdquo; given such a description are closely related to intuitions that live in various areas of non-monotonic reasoning.&lt;br /&gt;In this paper, we apply &lt;i&gt;approximation fixpoint theory&lt;/i&gt;, an abstract, algebraic framework designed to unify semantics of non-monotonic logics, to the field of AICs. This results in a new family of semantics for AICs. We study properties of our new semantics and relationships to existing semantics. In particular, we argue that the AFT-well-founded semantics has some very desirable properties.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Daniel Bundala, Michael Codish, Luís Cruz-Filipe, Peter Schneider-Kamp, &amp; Jakub Závodný. (2017). &lt;span class=&quot;paper-title&quot;&gt;Optimal-Depth Sorting Networks&lt;/span&gt;. Journal of Computer and System Sciences, 84, 185–204.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.jcss.2016.09.004</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper31.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We solve a 40-year-old open problem on the depth optimality of sorting networks. In 1973, Donald E.&amp;nbsp;Knuth detailed, in Volume&amp;nbsp;3 of &lt;i&gt;The Art of Computer Programming&lt;/i&gt;, sorting networks of the smallest depth known at the time for &lt;i&gt;n&lt;/i&gt;&amp;leq;16 inputs, quoting optimality for &lt;i&gt;n&lt;/i&gt;&amp;leq;8. In 1989, Parberry proved the optimality of the networks with 9&amp;leq;&lt;i&gt;n&lt;/i&gt;&amp;leq;10 inputs. In this article, we present a general technique for obtaining such optimality results, and use it to prove the optimality of the remaining open cases of 11&amp;leq;&lt;i&gt;n&lt;/i&gt;&amp;leq;16 inputs. We show how to exploit symmetry to construct a small set of two-layer networks on &lt;i&gt;n&lt;/i&gt; inputs such that if there is a sorting network on &lt;i&gt;n&lt;/i&gt; inputs of a given depth, then there is one whose first layers are in this set. For each network in the resulting set, we construct a propositional formula whose satisfiability is necessary for the existence of a sorting network of a given depth. Using an off-the-shelf SAT solver we show that the sorting networks listed by Knuth are optimal. For &lt;i&gt;n&lt;/i&gt;&amp;leq;10 inputs, our algorithm is orders of magnitude faster than the prior ones.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Michael Codish, Luís Cruz-Filipe, Markus Nebel, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;Optimizing Sorting Algorithms by Using Sorting Networks&lt;/span&gt;. Formal Aspects of Computing, 29, 559–579.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/s00165-016-0401-3</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper36.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>In this paper, we show how the theory of sorting networks can be applied to synthesize optimized general-purpose sorting libraries.  Standard sorting libraries are often based on combinations of the classic Quicksort algorithm, with insertion sort applied as base case for small, fixed, numbers of inputs.  Unrolling the code for the base case by ignoring loop conditions eliminates branching, resulting in code equivalent to a sorting network.  By replacing it with faster sorting networks, we can improve the performance of these algorithms.  We show that by considering the number of comparisons and swaps alone we are not able to predict any real advantage of this approach.  However, significant speed-ups are obtained when taking advantage of instruction level parallelism and non-branching conditional assignment instructions, both of which are common in modern CPU architectures.  Furthermore, a close control of how often registers have to be spilled to memory gives us a complete explanation of the performance of different sorting networks, allowing us to choose an optimal one for each particular architecture.  Our experimental results show that using code synthesized from these efficient sorting networks as the base case for Quicksort libraries results in significant real-world speed-ups.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Franco Callegati, Maurizio Gabbrielli, Saverio Giallorenzo, Andrea Melis, &amp; Marco Prandini. (2017). &lt;span class=&quot;paper-title&quot;&gt;Smart Mobility for All: A Global Federated Market for Mobility-as-a-Service Operators&lt;/span&gt;. In ITSC2017-20th International Conference on Intelligent Transportation.</content>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/itsc2017</link>
	</link>
		
		
	<tag>Smart Cities</tag>
		
	<tag>Microservices</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>Multi-modal travelling is a common phenomenon. However, planning multi-modal journeys is still an unstructured and time-consuming experience for customers: they lose time assembling a comprehensive plan out of disparate data, spread over a multitude of information systems — each corresponding to a different company responsible for one of the legs in the journey. Also transport operators are affected by the sparsity of the transportation market, as they might lose potential customers who could not find or know about their services. In this paper, we propose Mobility as a Service (MaaS) as a solution to such problems. Key element of MaaS is that MaaS operators can aggregate solutions of multiple providers to deliver dynamic, transparent multi-modal travels to their users, who experience transportation as managed directly by a single operator. However, given the volume and sparsity of the transportation market, we argue that MaaS operators cannot rely on one-to-one, custom contracts of usage with single mobility operators. Instead, we envision the creation of platforms that automatise the marketing of services for mobility among many mobility providers. In this work, we detail the required features of a general software platform for such a MaaS market. In particular, we provide a precise definition of MaaS through the MaaS Stack — a tiered view of the components needed by entities to join the MaaS market. Then, through the lens of the MaaS Stack, we elicit the features of an enabling software platform. Finally, to validate our approach, we present a compliant prototype, called SMAll, and discuss its main design choices, among which: i) how SMAll supports the creation of a federation-based MaaS market and ii) how microservices — an emerging architectural style that fosters cohesiveness and minimality of components — enhance flexibility and let the platform and the services of its members efficiently scale according to dynamic demands.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Franco Callegati, Saverio Giallorenzo, Andrea Melis, &amp; Marco Prandini. (2017). &lt;span class=&quot;paper-title&quot;&gt;Insider Threats in Emerging Mobility-as-a-Service Scenarios&lt;/span&gt;. In 50th Hawaii International Conference on System Sciences, HICSS 2017,  Hilton Waikoloa Village, Hawaii, USA, January 4-7, 2017. AIS Electronic Library (AISeL).</content>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/hicss2017/</link>
	</link>
		
		
	<tag>Security</tag>
		
	<tag>Microservices</tag>
		
	<tag>Smart Cities</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>Mobility as a Service (MaaS) applies the everything-as- a-service paradigm of Cloud Computing to transportation: a MaaS provider offers to its users the dynamic composition of solutions of different travel agencies into a single, consistent interface. Traditionally, transits and data on mobility belong to a scattered plethora of operators. Thus, we argue that the economic model of MaaS is that of federations of providers, each trading its resources to coordinate multi-modal solutions for mobility. Such flexibility comes with many security and privacy concerns, of which insider threat is one of the most prominent. In this paper, we follow a tiered structure — from individual operators to markets of federated MaaS providers — to classify the potential threats of each tier and propose the appropriate countermeasures, in an effort to mitigate the problems.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, Marijn Heule, Warren Hunt Jr., Matt Kaufmann, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;Efficient Certified RAT Verification&lt;/span&gt;. In L. de Moura (Ed.), CADE 2017 (Vol. 10395, pp. 220–236). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-63046-5_14</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper41.pdf</link>
	</link>
		
		
	<tag>Formal Proofs</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Clausal proofs have become a popular approach to validate the results of SAT solvers. However, validating clausal proofs in the most widely supported format (DRAT) is expensive even in highly optimized implementations.  We present a new format, called LRAT, which extends the DRAT format with hints that facilitate a simple and fast validation algorithm.  Checking validity of LRAT proofs can be implemented using trusted systems such as the languages supported by theorem provers.  We demonstrate this by implementing two certified LRAT checkers, one in Coq and one in ACL2.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, Graça Gaspar, &amp; Isabel Nunes. (2017). &lt;span class=&quot;paper-title&quot;&gt;From description-logic programs to multi-context systems&lt;/span&gt;. Journal of Logical and Algebraic Methods in Programming, 88, 26–44.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.jlamp.2017.01.005</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper32.pdf</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>The combination of logic program-style rules with other reasoning systems has been a fertile topic of research in the last years, with the proposal of several different systems that achieve this goal.  In this work, we look at two of these systems, dl-programs and multi-context systems, which address different aspects of this combination, and include different, incomparable programming constructs.  We prove that every dl-program can be transformed into a multi-context system in such a way that the different semantics for each paradigm are naturally related.  As a consequence, constructions developed for dl-programs can be automatically ported to multi-context systems.  In particular, we show how to model default rules over ontologies with the usual semantics.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, Kim S. Larsen, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;The Paths to Choreography Extraction&lt;/span&gt;. In J. Esparza &amp; A. S. Murawski (Eds.), FoSSaCS (Vol. 10203, pp. 424–440). Springer.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper33.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographies are global descriptions of interactions among concurrent components, most notably used in the settings of verification (e.g., Multiparty Session Types) and synthesis of correct-by-construction software (Choreographic Programming).  They require a top-down approach: programmers first write choreographies, and then use them to verify or synthesize their programs.  However, most existing software does not come with choreographies yet, which prevents their application.&lt;br /&gt;To attack this problem, we propose a novel methodology (called choreography extraction) that, given a set of programs or protocol specifications, automatically constructs a choreography that describes their behavior. The key to our extraction is identifying a set of paths in a graph that represents the symbolic execution of the programs of interest. Our method improves on previous work in several directions: we can now deal with programs that are equipped with a state and internal computation capabilities; time complexity is dramatically better; we capture programs that are correct but not necessarily synchronizable, i.e., they work because they exploit asynchronous communication.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, Kim S. Larsen, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;How to Get More Out of Your Oracles&lt;/span&gt;. In M. Ayala-Rincon &amp; C. Muñoz (Eds.), Interactive Theorem Proving – 8th International Conference, ITP 2017, Brası́lia, Brazil, September 26-29, 2017, Proceedings (Vol. 10499, pp. 164–170). Springer.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper43.pdf</link>
	</link>
		
		
	<tag>Formal Proofs</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Formal verification of large computer-generated proofs often relies on certified checkers based on oracles.  We propose a methodology for such proofs, advocating a separation of concerns between formalizing the underlying theory and optimizing the algorithm implemented in the checker, based on the observation that such optimizations can benefit significantly from adequately adapting the oracle.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, Kim S. Larsen, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;Formally Proving Size Optimality of Sorting Networks&lt;/span&gt;. Journal of Automated Reasoning, 59(4), 425–454.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper44.pdf</link>
	</link>
		
		
	<tag>Formal Proofs</tag>
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Recent successes in formally verifying increasingly larger computer-generated proofs have relied extensively on (a) using oracles, to find answers for recurring subproblems efficiently, and (b) extracting formally verified checkers, to perform exhaustive case analysis in feasible time.&lt;br /&gt;In this work we present a formal verification of optimality of sorting networks on up to 9 inputs, making it one of the largest computer-generated proofs that has been formally verified.  We show that an adequate pre-processing of the information provided by the oracle is essential for feasibility, as it improves the time required by our extracted checker by several orders of magnitude.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;A Core Model for Choreographic Programming&lt;/span&gt;. In O. Kouchnarenko &amp; R. Khosravi (Eds.), FACS (Vol. 10231, pp. 17–35). Springer.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper35.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.&lt;br /&gt;In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Encoding Asynchrony in Choreographies&lt;/span&gt;. In D. Shin &amp; M. Lencastre (Eds.), Proceedings of the Symposium on Applied Computing, SAC 2017, Marrakech, Morocco, April 3-7, 2017 (pp. 1175–1177).</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1145/3019612.3019901</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper38.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographies are widely used for the specification of concurrent and distributed software architectures.  Since asynchronous communications are ubiquitous in real-world systems, previous works have proposed different approaches for the formal modelling of asynchrony in choreographies.  Such approaches typically rely on ad-hoc syntactic terms or semantics for capturing the concept of messages in transit, yielding different formalisms that have to be studied separately.&lt;br /&gt;In this work, we take a different approach, and show that such extensions are not needed to reason about asynchronous communications in choreographies. Rather, we demonstrate how a standard choreography calculus already has all the needed expressive power to encode messages in transit (and thus asynchronous communications) through the primitives of process spawning and name mobility.  The practical consequence of our results is that we can reason about real-world systems within a choreography formalism that is simpler than those hitherto proposed.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Procedural Choreographic Programming&lt;/span&gt;. In A. Bouajjani &amp; A. Silva (Eds.), Formal Techniques for Distributed Objects, Components, and Systems – 37th IFIP WG 6.1 International Conference, FORTE 2017 (Vol. 10321, pp. 92–107). Springer.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper39.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is an emerging paradigm for correct-by-construction concurrent programming. However, its applicability is limited by the current lack of support for reusable procedures.&lt;br /&gt;We propose Procedural Choreographies (PC), a choreographic language model with full procedural abstraction. PC includes unbounded process creation and name mobility, yielding a powerful framework for writing correct concurrent algorithms that can be compiled into a process calculus. This increased expressivity requires a typing discipline to ensure that processes are properly connected when enacting procedures.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Cruz-Filipe Luı́s, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;That’s Enough: Asynchrony with Standard Choreography Primitives&lt;/span&gt;. In C. Caleiro, Dionı́sio Francisco, P. Gouveia, P. Mateus, &amp; J. Rasga (Eds.), Logic and Computation: Essays in Honour of Amı́lcar Sernadas (Vol. 33, pp. 125–142). College Publications.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper40.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographies are widely used for the specification of concurrent and distributed software architectures.  Since asynchronous communications are ubiquitous in real-world systems, previous works have proposed different approaches for the formal modelling of asynchrony in choreographies.  Such approaches typically rely on ad-hoc syntactic terms or semantics for capturing the concept of messages in transit, yielding different formalisms that have to be studied separately.&lt;br /&gt;In this work, we take a different approach, and show that such extensions are not needed to reason about asynchronous communications in choreographies. Rather, we demonstrate how a standard choreography calculus already has all the needed expressive power to encode messages in transit (and thus asynchronous communications) through the primitives of process spawning and name mobility.  The practical consequence of our results is that we can reason about real-world systems within a choreography formalism that is simpler than those hitherto proposed.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;On Asynchrony and Choreographies&lt;/span&gt;. In M. Bartoletti, L. Bocchi, L. Henrio, &amp; S. Knight (Eds.), Proceedings 10th Interaction and Concurrency Experience (Vol. 261, pp. 76–90). Open Publishing Association.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.4204/EPTCS.261.8</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper45.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically.  However, choreography languages are typically synchronous, whereas many real-world systems have asynchronous communications.  Previous attempts at enriching choreographies with asynchrony rely on &lt;i&gt;ad-hoc&lt;/i&gt; constructions, whose adequacy is only argued informally.  In this work, we formalise the properties that an asynchronous semantics for choreographies should have: messages can be sent without the intended receiver being ready, and all sent messages are eventually received.  We explore how out-of-order execution, used in choreographies for modelling concurrency, can be exploited to endow choreographies with an asynchronous semantics. Our approach satisfies the properties we identified.  We show how our development yields a pleasant correspondence with FIFO-based asynchronous messaging, modelled in a process calculus, and discuss how it can be adopted in more complex choreography models.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Cruz-Filipe Luı́s, Joao Marques-Silva, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;Efficient Certified Resolution Proof Checking&lt;/span&gt;. In A. Legay &amp; T. Margaria (Eds.), TACAS (Vol. 10205, pp. 118–135). Springer.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper34.pdf</link>
	</link>
		
		
	<tag>Formal Proofs</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We present a novel propositional proof tracing format that eliminates complex processing, thus enabling efficient (formal) proof checking.  The benefits of this format are demonstrated by implementing a proof checker in C, which outperforms a state-of-the-art checker by two orders of magnitude.  We then formalize the theory underlying propositional proof checking in Coq, and extract a correct-by-construction proof checker for our format from the formalization.  An empirical evaluation using 280 unsatisfiable instances from the 2015 and 2016 SAT competitions shows that this certified checker usually performs comparably to a state-of-the-art non-certified proof checker.  Using this format, we formally verify the recent 200 TB proof of the Boolean Pythagorean Triples conjecture.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Marco Carbone, Fabrizio Montesi, Carsten Schürmann, &amp; Nobuko Yoshida. (2017). &lt;span class=&quot;paper-title&quot;&gt;Multiparty session types as coherence proofs&lt;/span&gt;. Acta Inf., 54(3), 243–269.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/cmsy16.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Logic</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Luís Cruz-Filipe, &amp; Peter Schneider-Kamp. (2017). &lt;span class=&quot;paper-title&quot;&gt;Formally Proving the Boolean Triples Conjecture&lt;/span&gt;. In T. Eiter &amp; D. Sands (Eds.), Proceedings of LPAR-21 (Vol. 46, pp. 509–522). EasyChair Publications.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper37.pdf</link>
	</link>
		
		
	<tag>Formal Proofs</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>In 2016, Heule, Kullmann and Marek solved the Boolean Pythagorean Triples problem: is there a binary coloring of the natural numbers such that every Pythagorean triple contains an element of each color?  By encoding a finite portion of this problem as a propositional formula and showing its unsatisfiability, they established that such a coloring does not exist.  Subsequently, this answer was verified by a correct-by-construction checker extracted from a Coq formalization, which was able to reproduce the original proof.  However, none of these works address the question of formally addressing the relationship between the propositional formula that was constructed and the mathematical problem being considered.  In this work, we formalize the Boolean Pythagorean Triples problem in Coq.  We recursively define a family of propositional formulas, parameterized on a natural number &lt;i&gt;n&lt;/i&gt;, and show that unsatisfiability of this formula for any particular &lt;i&gt;n&lt;/i&gt; implies that there does not exist a solution to the problem.  We then formalize the mathematical argument behind the simplification step in the original proof of unsatisfiability and the logical argument underlying cube-and-conquer, obtaining a verified proof of Heule &lt;i&gt;et al.&lt;/i&gt;'s solution.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Nicola Dragoni, Saverio Giallorenzo, Alberto Lluch Lafuente, Manuel Mazzara, Fabrizio Montesi, Ruslan Mustafin, &amp; Larisa Safina. (2017). &lt;span class=&quot;paper-title&quot;&gt;Microservices: yesterday, today, and tomorrow&lt;/span&gt;. In Present and Ulterior Software Engineering (pp. 195–216). Springer.</content>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/msytt/</link>
	</link>
		
		
	<tag>Microservices</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Fabrizio Montesi</author>
		
	<author>Larisa Safina</author>
		
	<abstract>Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Saverio Giallorenzo, Ivan Lanese, Jacopo Mauro, &amp; Maurizio Gabbrielli. (2017). &lt;span class=&quot;paper-title&quot;&gt;Programming Adaptive Microservice Applications: An AIOCJ Tutorial&lt;/span&gt;. In S. Gay &amp; A. Ravara (Eds.), Behavioural Types: from Theory to Tools (pp. 147–167). River Publishers.</content>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/betty2017</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Microservices</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<abstract>This tutorial describes AIOCJ, which stands for Adaptive Interaction Oriented Choreographies in Jolie, a choreographic language for programming microservice-based applications which can be updated at runtime. The compilation of a single AIOCJ program generates the whole set of distributed microservices that compose the application. Adaptation is performed using adaptation rules. Abstractly, each rule replaces a pre-delimited part of the program with the new code contained in the rule itself. Concretely, at runtime, the application of a rule updates part of the microservices that compose the application so to match the behaviour specified by the updated program. Thanks to the properties of choreographies, the adaptive application is free from communication deadlocks and message races even after adaptation.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Claudio Guidi, Ivan Lanese, Manuel Mazzara, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Microservices: A Language-Based Approach&lt;/span&gt;. In Present and Ulterior Software Engineering (pp. 217–225). Springer.</content>
		
		
	<tag>Microservices</tag>
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Microservices is an emerging development paradigm where software is obtained by composing autonomous entities, called (micro)services. However, microservice systems are currently developed using general-purpose programming languages that do not provide dedicated abstractions for service composition. Instead, current practice is focused on the deployment aspects of microservices, in particular by using containerization. In this chapter, we make the case for a language-based approach to the engineering of microservice architectures, which we believe is complementary to current practice. We discuss the approach in general, and then we instantiate it in terms of the Jolie programming language.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Classical Higher-Order Processes - (Short Paper)&lt;/span&gt;. In FORTE (Vol. 10321, pp. 171–178). Springer.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/m17_forte.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Logic</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Classical Processes (CP) is a calculus where the proof theory of classical linear logic types processes `a la π-calculus, building on a CurryHoward correspondence between session types and linear propositions. We contribute to this research line by extending CP with process mobility, inspired by the Higher-Order π-calculus. The key to our calculus is that sequents are asymmetric: one side types sessions as in CP and the other types process variables, which can be instantiated with process values. The controlled interaction between the two sides ensures that process variables can be used at will, but always respecting the linear usage of sessions expected by the environment.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Alessio Mansutti, Marino Miculan, &amp; Marco Peressotti. (2017). &lt;span class=&quot;paper-title&quot;&gt;Loose Graph Simulations&lt;/span&gt;. In M. Seidl &amp; S. Zschaler (Eds.), Software Technologies: Applications and Foundations - STAF 2017  Collocated Workshops, Marburg, Germany, July 17-21, 2017, Revised  Selected Papers (Vol. 10748, pp. 109–126). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-74730-9_9</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>http://arxiv.org/abs/1705.08241</link>
	</link>
		
		
	<tag>Graph Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>We introduce loose graph simulations (LGS), a new notion about labelled graphs which subsumes in an intuitive and natural way subgraph isomorphism (SGI), regular language pattern matching (RLPM) and graph simulation (GS). Being a unification of all these notions, LGS allows us to express directly also problems which are &quot;mixed&quot; instances of previous ones, and hence which would not fit easily in any of them. After the definition and some examples, we show that the problem of finding loose graph simulations is NP-complete, we provide formal translation of SGI, RLPM, and GS into LGSs, and we give the representation of a problem which extends both SGI and RLPM. Finally, we identify a subclass of the LGS problem that is polynomial.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Marino Miculan, &amp; Marco Peressotti. (2017). &lt;span class=&quot;paper-title&quot;&gt;Deciding Weak Weighted Bisimulation&lt;/span&gt;. In D. Della Monica, A. Murano, S. Rubin, &amp; L. Sauro (Eds.), Joint Proceedings of the 18th Italian Conference on Theoretical Computer  Science and the 32nd Italian Conference on Computational Logic co-located  with the 2017 IEEE International Workshop on Measurements and Networking  (2017 IEEE M&amp;N), Naples, Italy, September 26-28, 2017. (Vol. 1949, pp. 126–137). CEUR-WS.org.</content>
		
	<link>
		<name>paper</name>
		<link>http://ceur-ws.org/Vol-1949/ICTCSpaper11.pdf</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Weighted labelled transition systems are LTSs whose transitions are given weights drawn from a commutative monoid, subsuming a wide range of systems with quantitative aspects. In this paper we extend this theory towards other behavioural equivalences, by considering semirings of weights. Taking advantage of this extra structure, we consider a general notion of weak weighted bisimulation, which coincides with the usual weak bisimulations in the cases of non-deterministic and fully-probabilistic systems. We present a general algorithm for deciding weak weighted bisimulation. The procedure relies on certain systems of linear equations over the semiring of weights hence it can be readily instantiated to a wide range of models. We prove that these systems admit a unique solution for ω-continuous semirings</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Fabrizio Montesi, &amp; Dan Sebastian Thrane. (2017). &lt;span class=&quot;paper-title&quot;&gt;Packaging Microservices - (Work in Progress)&lt;/span&gt;. In DAIS (Vol. 10320, pp. 131–137). Springer.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/mt17.pdf</link>
	</link>
		
		
	<tag>Microservices</tag>
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We describe a first proposal for a new packaging system for microservices based on the Jolie programming language, called the Jolie Package Manager (JPM). Its main features revolve around service interfaces, which make the functionalities that a service provides and depends on explicit. For the first time, JPM supports binding a service to an externally-provided package, and a notion of interface parametricity that can be used to develop generic service libraries that can modify the behaviour of arbitrary services. We illustrate the latter with a generic circuit breaker package.</abstract>
</paper>
	
<paper>
	<year>2017</year>
	<content>Mila Dalla Preda, Maurizio Gabbrielli, Saverio Giallorenzo, Ivan Lanese, &amp; Jacopo Mauro. (2017). &lt;span class=&quot;paper-title&quot;&gt;Dynamic Choreographies: Theory And Implementation&lt;/span&gt;. Logical Methods in Computer Science, 13(2).</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.23638/LMCS-13(2:1)2017</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/lmcs2017/</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Adaptation</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<abstract>Programming distributed applications free from communication deadlocks and race conditions is complex. Preserving these properties when applications are updated at runtime is even harder. We present a choreographic approach for programming updatable, distributed applications. We define a choreography language, called Dynamic Interaction-Oriented Choreography (DIOC), that allows the programmer to specify, from a global viewpoint, which parts of the application can be updated. At runtime, these parts may be replaced by new DIOC fragments from outside the application. DIOC programs are compiled, generating code for each participant in a process-level language called Dynamic Process-Oriented Choreographies (DPOC). We prove that DPOC distributed applications generated from DIOC specifications are deadlock free and race free and that these properties hold also after any runtime update. We instantiate the theoretical model above into a programming framework called Adaptable Interaction-Oriented Choreographies in Jolie (AIOCJ) that comprises an integrated development environment, a compiler from an extension of DIOCs to distributed Jolie programs, and a runtime environment to support their execution.</abstract>
</paper>
	

	
<paper>
	<year>2016</year>
	<content>Tomasz Brengos, &amp; Marco Peressotti. (2016). &lt;span class=&quot;paper-title&quot;&gt;A Uniform Framework for Timed Automata&lt;/span&gt;. In J. Desharnais &amp; R. Jagadeesan (Eds.), 27th International Conference on Concurrency Theory (CONCUR 2016) (Vol. 59, pp. 26:1–26:15). Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.4230/LIPIcs.CONCUR.2016.26</link>
	</link>
		
	<link>
		<name></name>
		<link>http://drops.dagstuhl.de/opus/volltexte/2016/6169/pdf/LIPIcs-CONCUR-2016-26.pdf</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Coalgebras</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Timed automata, and machines alike, currently lack a general mathematical characterisation. In this paper we provide a uniform coalgebraic understanding of these devices. This framework encompasses known behavioural equivalences for timed automata and paves the way for the extension of these notions to new timed behaviours and for the instantiation of established results from the coalgebraic theory as well. Key to this work is the use of lax functors for they allow us to model time flow as a context property and hence offer a general and expressive setting where to study timed systems: the index category encodes &quot;how step sequences form executions&quot; (e.g. whether steps duration get accumulated or kept distinct) whereas the base category encodes &quot;step nature and composition&quot; (e.g. non-determinism and labels). Finally, we develop the notion of general saturation for lax functors and show how equivalences of interest for timed behaviours are instances of this notion. This characterisation allows us to reason about the expressiveness of said notions within a uniform framework and organise them in a spectrum independent from the behavioural aspects encoded in the base category.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Luís Cruz-Filipe. (2016). &lt;span class=&quot;paper-title&quot;&gt;Grounded Fixpoints and Active Integrity Constraints&lt;/span&gt;. In M. Carro, A. King, M. De Vos, &amp; N. Saeedloei (Eds.), Technical Communications of the 32nd International Conference on Logic Programming (ICLP’16) (Vol. 52, pp. 11.1–11.14). Schloss Dagstuhl.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.4230/OASIcs.ICLP.2016.11</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper28.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>The formalism of active integrity constraints was introduced as a way to specify particular classes of integrity constraints over relational databases together with preferences on how to repair existing inconsistencies.  The rule-based syntax of such integrity constraints also provides algorithms for finding such repairs that achieve the best asymptotic complexity.&lt;br /&gt;However, the different semantics that have been proposed for these integrity constraints all exhibit some counter-intuitive examples.  In this work, we look at active integrity constraints using ideas from algebraic fixpoint theory.  We show how database repairs can be modeled as fixpoints of particular operators on databases, and study how the notion of grounded fixpoint induces a corresponding notion of grounded database repair that captures several natural intuitions, and in particular avoids the problems of previous alternative semantics.&lt;br /&gt;In order to study grounded repairs in their full generality, we need to generalize the notion of grounded fixpoint to non-deterministic operators.  We propose such a definition and illustrate its plausibility in the database context.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Michael Codish, Luís Cruz-Filipe, Michael Frank, &amp; Peter Schneider-Kamp. (2016). &lt;span class=&quot;paper-title&quot;&gt;Sorting nine inputs requires twenty-five comparisons&lt;/span&gt;. Journal of Computer and System Sciences, 82(3), 551–563.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.jcss.2015.11.014</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper26.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>This paper describes a computer-assisted non-existence proof of 9-input sorting networks consisting of 24 comparators, hence showing that the 25-comparator sorting network found by Floyd in 1964 is optimal. As a corollary, the 29-comparator network found by Waksman in 1969 is optimal when sorting 10 inputs.&lt;br /&gt;This closes the two smallest open instances of the optimal-size sorting network problem, which have been open since the results of Floyd and Knuth from 1966 proving optimality for sorting networks of up to 8 inputs.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Luís Cruz-Filipe, Michael Franz, Artavazd Hakhverdyan, Marta Ludovico, Isabel Nunes, &amp; Peter Schneider-Kamp. (2016). &lt;span class=&quot;paper-title&quot;&gt;Active Integrity Constraints: from Theory to Implementation&lt;/span&gt;. In A. Fred, J. L. G. Dietz, D. Aveiro, K. Liu, &amp; J. Filipe (Eds.), Knowledge Discovery, Knowledge Engineering and Knowledge Management (pp. 399–420). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-662-46549-3_13</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper30.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>The problem of database consistency relative to a set of integrity constraints has been extensively studied since the 1980s, and is still recognized as one of the most important and complex in the field.  In recent years, with the proliferation of knowledge repositories (not only databases) in practical applications, there has also been an effort to develop implementations of consistency maintenance algorithms that have a solid theoretical basis.&lt;br /&gt;The framework of active integrity constraints (AICs) is one example of such an effort, providing theoretical grounds for rule-based algorithms for ensuring database consistency.  An AIC consists of an integrity constraint together with a specification of actions that may be taken to repair a database that does not satisfy it.  Both denotational and operational semantics have been proposed for AICs.&lt;br /&gt;In this paper, we describe &lt;code&gt;repAIrC&lt;/code&gt;, a prototype implementation of the algorithms previously proposed targetting SQL databases, i.e., the most prolific type of databases.  Using &lt;code&gt;repAIrC&lt;/code&gt;, we can both validate an SQL database with respect to a given set of AICs and compute possible repairs in case the database is inconsistent; the tool is able to work with the different kinds of repairs that have been considered, and achieves optimal asymptotic complexity in their computation.  It also implements strategies for parallelizing the search for repairs, which in many cases can make untractable problems become easily solvable.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Franco Callegati, Saverio Giallorenzo, Andrea Melis, &amp; Marco Prandini. (2016). &lt;span class=&quot;paper-title&quot;&gt;Data security issues in MaaS-enabling platforms&lt;/span&gt;. In IEEE 2nd International Forum on Research and Technologies for Society  and Industry Leveraging a better tomorrow, RTSI 2016, Bologna, Italy,  September 7-9, 2016 (pp. 1–5). IEEE.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1109/RTSI.2016.7740624</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/rtsi2016/</link>
	</link>
		
		
	<tag>Security</tag>
		
	<tag>Microservices</tag>
		
	<tag>Smart Cities</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>Microservices is an emerging paradigm for the development of distributed systems that, originating from Service-Oriented Architecture, focuses on the small dimension, the loose coupling, and the dynamic topology of services. Microservices are particularly appropriate for the development of distributed systems in the Cloud. However, their dynamic nature calls for suitable techniques for their automatic deployment. In this paper we address this problem and we propose JRO (Jolie Redeployment Optimiser), a tool for the automatic and optimised deployment of microservices written in the Jolie language. The tool uses Zephyrus, a state of the art tool that automatically generates a fully detailed Service-Oriented Architecture configuration starting from a partial and abstract description of the target application.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Luís Cruz-Filipe, Graça Gaspar, Isabel Nunes, &amp; Peter Schneider-Kamp. (2016). &lt;span class=&quot;paper-title&quot;&gt;Active Integrity Constraints for Multi-Context Systems&lt;/span&gt;. In E. Blomqvist, F. Vitali, P. Ciancarini, &amp; F. Poggi (Eds.), Knowledge Engineering and Knowledge Management – 20th International Conference, EKAW 2016, Bologna, Italy, November 19-23, 2016. Proceedings (Vol. 10024, pp. 98–112). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-49004-5_7</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper29.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We introduce a formalism to couple integrity constraints over general-purpose knowledge bases with actions that can be executed to restore consistency.  This formalism generalizes active integrity constraints over databases.  In the more general setting of multi-context systems, adding repair suggestions to integrity constraints allows defining simple iterative algorithms to find all possible grounded repairs &amp;ndash; repairs for the global system that follow the suggestions given by the actions in the individual rules.  We apply our methodology to ontologies, and show that it can express most relevant types of integrity constraints in this domain.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Choreographies in Practice&lt;/span&gt;. In E. Albert &amp; I. Lanese (Eds.), Formal Techniques for Distributed Objects, Components, and Systems – 36th IFIP WG 6.1 International Conference, FORTE 2016 (Vol. 9688, pp. 114–123). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-39570-8_8</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper27.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a development methodology for concurrent software that guarantees correctness by construction. The key to this paradigm is to disallow mismatched I/O operations in programs, and mechanically synthesise process implementations.&lt;br /&gt;There is still a lack of practical illustrations of the applicability of choreographies to computational problems with standard concurrent solutions. In this work, we explore the potential of choreographic programming by writing concurrent algorithms for sorting, solving linear equations, and computing Fast Fourier Transforms. The lessons learned from this experiment give directions for future improvements of the paradigm.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Luís Cruz-Filipe, Isabel Nunes, &amp; Peter Schneider-Kamp. (2016). &lt;span class=&quot;paper-title&quot;&gt;Integrity Constraints for General-Purpose Knowledge Bases&lt;/span&gt;. In M. Gyssens &amp; G. Simari (Eds.), Foundations of Information and Knowledge Systems – 9th International Symposium, FoIKS 2016, Linz, Austria, March 7–11, 2016. Proceedings (Vol. 9616, pp. 235–254). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-30024-5_13</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper25.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Integrity constraints in databases have been studied extensively since the 1980s, and they are considered essential to guarantee database integrity. In recent years, several authors have studied how the same notion can be adapted to reasoning frameworks, in such a way that they achieve the purpose of guaranteeing a system's consistency, but are kept separate from the reasoning mechanisms.&lt;br /&gt;In this paper we focus on multi-context systems, a general-purpose framework for combining heterogeneous reasoning systems, enhancing them with a notion of integrity constraints that generalizes the corresponding concept in the database world.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Larisa Safina, Manuel Mazzara, Fabrizio Montesi, &amp; Rivera Vı́ctor. (2016). &lt;span class=&quot;paper-title&quot;&gt;Data-Driven Workflows for Microservices: Genericity in Jolie&lt;/span&gt;. In AINA (pp. 430–437). IEEE Computer Society.</content>
		
	<link>
		<name></name>
		<link>https://arxiv.org/abs/1511.02597</link>
	</link>
		
		
	<tag>Microservices</tag>
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<author>Larisa Safina</author>
		
	<abstract>Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Jolie is a programming language based on the microservices paradigm: the main building block of Jolie systems are services, in contrast to, e.g., functions or objects. The primitives offered by the Jolie language elicit many of the recurring patterns found in microservices, like load balancers and structured processes. However, Jolie still lacks some useful constructs for dealing with message types and data manipulation that are present in service-oriented computing. In this paper, we focus on the possibility of expressing choices at the level of data types, a feature well represented in standards for Web Services, e.g., WSDL. We extend Jolie to support such type choices and show the impact of our implementation on some of the typical scenarios found in microservice systems. This shows how computation can move from a process-driven to a data-driven approach, and leads to the preliminary identification of recurring communication patterns that can be shaped as design patterns.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Marco Carbone, Sam Lindley, Fabrizio Montesi, Carsten Schürmann, &amp; Philip Wadler. (2016). &lt;span class=&quot;paper-title&quot;&gt;Coherence Generalises Duality: A Logical Explanation of Multiparty  Session Types&lt;/span&gt;. In CONCUR (Vol. 59, pp. 33:1–33:15). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.</content>
		
	<link>
		<name>publisher's website</name>
		<link>http://drops.dagstuhl.de/opus/volltexte/2016/6181/</link>
	</link>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/clmsw16.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Logic</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Wadler introduced Classical Processes (CP), a calculus based on a propositions-as-types correspondence between propositions of classical linear logic and session types. Carbone et al. introduced Multiparty Classical Processes, a calculus that generalises CP to multiparty session types, by replacing the duality of classical linear logic (relating two types) with a more general notion of coherence (relating an arbitrary number of types). This paper introduces variants of CP and MCP, plus a new intermediate calculus of Globally-governed Classical Processes (GCP). We show a tight relation between these three calculi, giving semantics-preserving translations from GCP to CP and from MCP to GCP. The translation from GCP to CP interprets a coherence proof as an arbiter process that mediates communications in a session, while MCP adds annotations that permit processes to communicate directly without centralised control.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Davide Ancona, Viviana Bono, Mario Bravetti, Joana Campos, Giuseppe Castagna, Pierre-Malo Deniélou, … Nobuko Yoshida. (2016). &lt;span class=&quot;paper-title&quot;&gt;Behavioral Types in Programming Languages&lt;/span&gt;. Foundations and Trends in Programming Languages, 3(2-3), 95–230.</content>
		
	<link>
		<name>publisher's website</name>
		<link>https://www.nowpublishers.com/article/Details/PGL-031</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Session Types</tag>
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>A recent trend in programming language research is to use behavioral type theory to ensure various correctness properties of largescale, communication-intensive systems. Behavioral types encompass concepts such as interfaces, communication protocols, contracts, and choreography. The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account. This survey provides an overview of the state of the art of these aspects, which we summarize as the pragmatics of behavioral types.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Process-aware web programming with Jolie&lt;/span&gt;. Sci. Comput. Program., 130, 69–96.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/m16.pdf</link>
	</link>
		
		
	<tag>Microservices</tag>
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We extend the Jolie programming language to capture the native modelling of process-aware web information systems, i.e., web information systems based upon the execution of business processes. Our main contribution is to offer a unifying approach for the programming of distributed architectures on the web, which can capture web servers, stateful process execution, and the composition of services via mediation. We discuss applications of this approach through a series of examples that cover, e.g., static content serving, multiparty sessions, and the evolution of web systems. Finally, we present a performance evaluation that includes a comparison of Jolie-based web systems to other frameworks and a measurement of its scalability.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Dario De Nart, Dante Degl’Innocenti, &amp; Marco Peressotti. (2016). &lt;span class=&quot;paper-title&quot;&gt;Well-Stratified Linked Data for Well-Behaved Data Citation&lt;/span&gt;. TCDL Bulletin, 12(1).</content>
		
	<link>
		<name>paper</name>
		<link>http://www.ieee-tcdl.org/Bulletin/v12n1/papers/IEEE-TCDL-DC-2016_paper_2.pdf</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1512.02898</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>In this paper we analyse the functional requirements of linked data citation and identify a minimal set of operations and primitives needed to realise such task. Citing linked data implies solving a series of data provenance issues and finding a way to identify data subsets. Those two tasks can be handled defining a simple type system inside data and verifying it with a type checker, which is significantly less complex than interpreting reified RDF statements and can be implemented in a non data invasive way. Finally we suggest that data citation should be handled outside of the data, possibly with an ad hoc language.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Dario De Nart, Dante Degl’Innocenti, Marco Peressotti, &amp; Carlo Tasso. (2016). &lt;span class=&quot;paper-title&quot;&gt;Stratifying Semantic Data for Citation and Trust: An Introduction  to RDFDF&lt;/span&gt;. In M. Agosti, M. Bertini, S. Ferilli, S. Marinai, &amp; N. Orio (Eds.), Digital Libraries and Multimedia Archives - 12th Italian Research  Conference on Digital Libraries, IRCDL 2016, Florence, Italy, February  4-5, 2016, Revised Selected Papers (Vol. 701, pp. 104–111).</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-56300-8_10</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>In this paper we analyse the functional requirements of linked data citation and identify a minimal set of operations and primitives needed to realise such task. Citing linked data implies solving a series of data provenance issues and finding a way to identify data subsets. Those two tasks can be handled defining a simple type system inside data and verifying it with a type checker, which is significantly less complex than interpreting reified RDF statements and can be implemented in a non data invasive way. Finally we suggest that data citation should be handled outside of the data, and propose a simple language to describe RDF documents where separation between data and metainformation is explicitly specified.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Maurizio Gabbrielli, Saverio Giallorenzo, Claudio Guidi, Jacopo Mauro, &amp; Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Self-Reconfiguring Microservices&lt;/span&gt;. In Theory and Practice of Formal Methods - Essays Dedicated to Frank  de Boer on the Occasion of His 60th Birthday (pp. 194–210). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-30734-3_14</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/self-reconfiguring/</link>
	</link>
		
		
	<tag>Microservices</tag>
		
	<tag>Optimisation</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Microservices is an emerging paradigm for the development of distributed systems that, originating from Service-Oriented Architecture, focuses on the small dimension, the loose coupling, and the dynamic topology of services. Microservices are particularly appropriate for the development of distributed systems in the Cloud. However, their dynamic nature calls for suitable techniques for their automatic deployment. In this paper we address this problem and we propose JRO (Jolie Redeployment Optimiser), a tool for the automatic and optimised deployment of microservices written in the Jolie language. The tool uses Zephyrus, a state of the art tool that automatically generates a fully detailed Service-Oriented Architecture configuration starting from a partial and abstract description of the target application.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Marino Miculan, &amp; Marco Peressotti. (2016). &lt;span class=&quot;paper-title&quot;&gt;Structural operational semantics for non-deterministic processes with  quantitative aspects&lt;/span&gt;. Theor. Comput. Sci., 655, 135–154.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.tcs.2016.01.012</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1410.0893</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Coalgebras</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Recently, unifying theories for processes combining non-determinism with quantitative aspects (such as probabilistic or stochastically timed executions) have been proposed with the aim of providing general results and tools. This paper provides two contributions in this respect. First, we present a general GSOS specification format and a corresponding notion of bisimulation for non-deterministic processes with quantitative aspects. These specifications define labelled transition systems according to the ULTraS model, an extension of the usual LTSs where the transition relation associates any source state and transition label with state reachability weight functions (like, e.g., probability distributions). This format, hence called Weight Function GSOS (WF-GSOS), covers many known systems and their bisimulations (e.g. PEPA, TIPP, PCSP) and GSOS formats (e.g. GSOS, Weighted GSOS, Segala-GSOS). &lt;br/&gt; The second contribution is a characterization of these systems as coalgebras of a class of functors, parametric in the weight structure. This result allows us to prove soundness and completeness of the WF-GSOS specification format, and that bisimilarities induced by these specifications are always congruences.</abstract>
</paper>
	
<paper>
	<year>2016</year>
	<content>Marino Miculan, &amp; Marco Peressotti. (2016). &lt;span class=&quot;paper-title&quot;&gt;On the Bisimulation Hierarchy of State-to-Function Transition Systems&lt;/span&gt;. In V. Bilò &amp; A. Caruso (Eds.), Proceedings of the 17th Italian Conference on Theoretical Computer  Science, Lecce, Italy, September 7-9, 2016. (Vol. 1720, pp. 88–102). CEUR-WS.org.</content>
		
	<link>
		<name>paper</name>
		<link>http://ceur-ws.org/Vol-1720/full7.pdf</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Coalgebras</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Weighted labelled transition systems (WLTSs) are an established (meta-)model aiming to provide general results and tools for a wide range of systems such as non-deterministic, stochastic, and probabilistic systems. In order to encompass processes combining several quantitative aspects, extensions of the WLTS framework have been further proposed, state-to-function transition systems (FuTSs) and uniform labelled transition systems (ULTraSs) being two prominent examples. In this paper we show that this hierarchy of meta-models collapses when studied under the lens of bisimulation-coherent encodings.</abstract>
</paper>
	

	
<paper>
	<year>2015</year>
	<content>Tomasz Brengos, Marino Miculan, &amp; Marco Peressotti. (2015). &lt;span class=&quot;paper-title&quot;&gt;Behavioural equivalences for coalgebras with unobservable moves&lt;/span&gt;. J. Log. Algebr. Meth. Program., 84(6), 826–852.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.jlamp.2015.09.002</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1411.0090</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Coalgebras</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>We introduce a general categorical framework for the definition of weak behavioural equivalences, building on and extending recent results in the field. This framework is based on parametrized saturation categories, i.e. categories whose hom-sets are endowed with complete orders and a suitable iteration operators; this structure allows us to provide the abstract definitions of various (weak) behavioural equivalence. We show that the Kleisli categories of many common monads are categories of this kind. This allows us to readily instantiate the abstract definitions to a wide range of existing systems (weighted LTS, Segala systems, calculi with names, etc.), recovering the corresponding notions of weak behavioural equivalences. Moreover, we can provide neatly new weak behavioural equivalences for more complex behaviours, like those definable on topological spaces, measurable spaces, etc.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Michael Codish, Luís Cruz-Filipe, Markus Nebel, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;Applying Sorting Networks to Synthesize Optimized Sorting Libraries&lt;/span&gt;. In M. Falaschi (Ed.), Logic-Based Program Synthesis and Transformation – 25th International Symposium, LOPSTR 2015, Siena, Italy, July 13–15, 2015. Revised Selected Papers (Vol. 9527, pp. 127–142). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-27436-2</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper24.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>This paper shows an application of the theory of sorting networks to facilitate the synthesis of optimized general purpose sorting libraries. Standard sorting libraries are often based on combinations of the classic Quicksort algorithm with insertion sort applied as the base case for small fixed numbers of inputs. Unrolling the code for the base case by ignoring loop conditions eliminates branching and results in code which is equivalent to a sorting network. This enables the application of further program transformations based on sorting network optimizations, and eventually the synthesis of code from sorting networks. We show that if considering the number of comparisons and swaps then theory predicts no real advantage of this approach. However, significant speed-ups are obtained when taking advantage of instruction level parallelism and non-branching conditional assignment instructions, both of which are common in modern CPU architectures. We provide empirical evidence that using code synthesized from efficient sorting networks as the base case for Quicksort libraries results in significant real-world speed-ups.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Michael Codish, Luís Cruz-Filipe, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;Sorting networks: the end game&lt;/span&gt;. In A.-H. Dediu, E. Formenti, Martı́n-Vide Carlos, &amp; B. Truthe (Eds.), Language and Automata Theory and Applications – 9th International Conference, LATA 2015, Nice, France, March 2-6, 2015, Proceedings (Vol. 8977, pp. 664–675). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-15579-1_52</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper18.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>This paper studies properties of the back end of a sorting network and illustrates the utility of these in the search for networks of optimal size or depth. All previous works focus on properties of the front end of networks and on how to apply these to break symmetries in the search. The new properties help shed understanding on how sorting networks sort and speed-up solvers for both optimal size and depth by an order of magnitude.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Luís Cruz-Filipe, &amp; Fernando Ferreira. (2015). &lt;span class=&quot;paper-title&quot;&gt;The Finitistic Consistency of Heck’s Predicative Fregean System&lt;/span&gt;. Notre-Dame Journal of Formal Logic, 56(1), 61–79.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper19.pdf</link>
	</link>
		
		
	<tag>Logic</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Frege's theory is inconsistent (Russell's paradox). However, the predicative version of Frege's system is consistent. This was proved by Richard Heck in 1996 using a model theoretic argument. In this paper, we give a finitistic proof of this consistency result. As a consequence, Heck's predicative theory is rather weak (as was suspected). We also prove the finitistic consistency of the extension of Heck's theory to &amp;Delta;&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;1&lt;/sub&gt;-comprehension and of Heck's ramified predicative second-order system.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Luís Cruz-Filipe, Michael Franz, Artavazd Hakhverdyan, Marta Ludovico, Isabel Nunes, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;repAIrC: A Tool for Ensuring Data Consistency by Means of Active Integrity Constraints&lt;/span&gt;. In A. Fred, J. Dietz, D. Aveiro, K. Liu, &amp; J. Filipe (Eds.), Proceedings of the 7th International Joint Conference on Knowledge Discovery, Knowledge Engineering and Knowledge Management (IC3K2015) (Vol. 3, pp. 17–26). SCITEPRESS.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.5220/0005586400170026</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper23.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Consistency of knowledge repositories is of prime importance in organization management. Integrity constraints are a well-known vehicle for specifying data consistency requirements in knowledge bases; in particular, active integrity constraints go one step further, allowing the specification of preferred ways to overcome inconsistent situations in the context of database management.&lt;br /&gt;This paper describes a tool to validate an SQL database with respect to a given set of active integrity constraints, proposing possible repairs in case the database is inconsistent. The tool is able to work with the different kinds of repairs proposed in the literature, namely simple, founded, well-founded and justified repairs. It also implements strategies for parallelizing the search for them, allowing the user both to compute partitions of independent or stratified active integrity constraints, and to apply these partitions to find repairs of inconsistent databases efficiently in parallel.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Luís Cruz-Filipe, Graça Gaspar, &amp; Isabel Nunes. (2015). &lt;span class=&quot;paper-title&quot;&gt;Design Patterns for Description-logic Programs&lt;/span&gt;. In A. Fred, J. L. G. Dietz, K. Liu, &amp; J. Filipe (Eds.), Knowledge Discovery, Knowledge Engineering and Knowledge Management (Vol. 454, pp. 199–214). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-662-46549-3_13</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper20.pdf</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Originally proposed in the mid-90s, design patterns for software development played a key role in object-oriented programming not only in increasing software quality, but also by giving a better understanding of the power and limitations of this paradigm. Since then, several authors have endorsed a similar task for other programming paradigms, in the hope of achieving similar benefits.&lt;br /&gt;In this paper we present a set of design patterns for Mdl-programs, a hybrid formalism combining several description logic knowledge bases via a logic program. These patterns are extensively applied in a natural way in a large-scale example that illustrates how their usage greatly simplifies some programming tasks, at the level of both development and extension.&lt;br /&gt;We also discuss some limitations of this formalism, examining some usual patterns in other programming paradigms that have no parallel in Mdl-programs.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Luís Cruz-Filipe, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;Optimizing a Certified Proof Checker for a Large-Scale Computer-Generated Proof&lt;/span&gt;. In M. Kerber, J. Carette, C. Kaliszyk, F. Rabe, &amp; V. Sorge (Eds.), Intelligent Computer Mathematics – International Conference, CICM 2015, Washington, DC, USA, July 13-17, 2015, Proceedings (Vol. 9150, pp. 55–70). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-20615-8_4</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper21.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>In recent work, we formalized the theory of optimal-size sorting networks with the goal of extracting a verified checker for the large-scale computer-generated proof that 25 comparisons are optimal when sorting 9 inputs, which required more than a decade of CPU time and produced 27 GB of proof witnesses.  The checker uses an untrusted oracle based on these witnesses and is able to verify the smaller case of 8 inputs within a couple of days, but it did not scale to the full proof for 9 inputs.&lt;br /&gt;In this paper, we describe several non-trivial optimizations of the algorithm in the checker, obtained by appropriately changing the formalization and capitalizing on the symbiosis with an adequate implementation of the oracle. We provide experimental evidence of orders of magnitude improvements to both runtime and memory footprint for 8 inputs, and actually manage to check the full proof for 9 inputs.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Luís Cruz-Filipe, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;Formalizing Size-Optimal Sorting Networks: Extracting a Certified Proof Checker&lt;/span&gt;. In C. Urban &amp; X. Zhang (Eds.), Interactive Theorem Proving – 6th International Conference, ITP 2015, Nanjing, China, August 24-27, 2015, Proceedings (Vol. 9236, pp. 154–169). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-22102-1_10</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper22.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Since the proof of the four color theorem in 1976, computer-generated proofs have become a reality in mathematics and computer science. During the last decade, we have seen formal proofs using verified proof assistants being used to verify the validity of such proofs.&lt;br /&gt;In this paper, we describe a formalized theory of size-optimal sorting networks. From this formalization we extract a certified checker that successfully verifies computer-generated proofs of optimality on up to 8 inputs. The checker relies on an untrusted oracle to shortcut the search for witnesses on more than 1.6 million NP-complete subproblems.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Marco Carbone, Fabrizio Montesi, Carsten Schürmann, &amp; Nobuko Yoshida. (2015). &lt;span class=&quot;paper-title&quot;&gt;Multiparty Session Types as Coherence Proofs&lt;/span&gt;. In L. Aceto &amp; D. de Frutos-Escrig (Eds.), 26th International Conference on Concurrency Theory, CONCUR 2015,  Madrid, Spain, September 1.4, 2015 (Vol. 42, pp. 412–426). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.4230/LIPIcs.CONCUR.2015.412</link>
	</link>
		
	<link>
		<name></name>
		<link>https://www.fabriziomontesi.com/files/cmsy15.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Logic</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Kickstarting Choreographic Programming&lt;/span&gt;. In T. T. Hildebrandt, A. Ravara, J. M. van der Werf, &amp; M. Weidlich (Eds.), Web Services, Formal Methods, and Behavioral Types - 11th International  Workshop, WS-FM 2014, Eindhoven, The Netherlands, September 11-12,  2014, and 12th International Workshop, WS-FM/BEAT 2015, Madrid,  Spain, September 4-5, 2015, Revised Selected Papers (Vol. 9421, pp. 3–10). Springer.</content>
		
	<link>
		<name></name>
		<link>http://arxiv.org/abs/1502.02519</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We present an overview of some recent efforts aimed at the development of Choreographic Programming, a programming paradigm for the production of concurrent software that is guaranteed to be correct by construction from global descriptions of communication behaviour.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Mario Bravetti, Alberto Lluch-Lafuente, Manuel Mazzara, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Guest Editorial: Special Issue on Service-Oriented Architectures and  Programming&lt;/span&gt;. J. Internet Serv. Inf. Secur., 5(1), 1–2.</content>
		
	<link>
		<name>paper</name>
		<link>http://isyou.info/jisis/vol5/no1/jisis-2015-vol5-no1-00.pdf</link>
	</link>
		
		
	<tag>Service-Oriented Computing</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract></abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Ivan Lanese, Manuel Mazzara, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Special issue on Service-Oriented Architecture and Programming (SOAP  2013)&lt;/span&gt;. Sci. Comput. Program., 97, 181–182.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.scico.2014.07.007</link>
	</link>
		
	<link>
		<name>paper</name>
		<link>https://doi.org/10.1016/j.scico.2014.07.007</link>
	</link>
		
		
	<tag>Service-Oriented Computing</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract></abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Ivan Lanese, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2015). &lt;span class=&quot;paper-title&quot;&gt;The Evolution of Jolie - From Orchestrations to Adaptable Choreographies&lt;/span&gt;. In R. D. Nicola &amp; R. Hennicker (Eds.), Software, Services, and Systems - Essays Dedicated to Martin Wirsing  on the Occasion of His Retirement from the Chair of Programming and  Software Engineering (Vol. 8950, pp. 506–521). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-15545-6_29</link>
	</link>
		
	<link>
		<name></name>
		<link>https://www.fabriziomontesi.com/files/lmz15.pdf</link>
	</link>
		
		
	<tag>Jolie</tag>
		
	<tag>Choreographic Programming</tag>
		
	<tag>Adaptation</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Jolie is an orchestration language conceived during Sensoria, an FP7 European project led by Martin Wirsing in the time frame 2005–2010. Jolie was designed having in mind both the novel –at project time– concepts related to Service-Oriented Computing and the traditional approach to the modelling of concurrency typical of process calculi. The foundational work done around Jolie during Sensoria has subsequently produced many concrete results. In this paper we focus on two distinct advancements, one aiming at the development of dynamically adaptable orchestrated systems and one focusing on global choreographic specifications. These works, more recently, contributed to the realisation of a framework for programming dynamically evolvable distributed ServiceOriented applications that are correct-by-construction</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Marino Miculan, Marco Peressotti, &amp; Andrea Toneguzzo. (2015). &lt;span class=&quot;paper-title&quot;&gt;Open Transactions on Shared Memory&lt;/span&gt;. In T. Holvoet &amp; M. Viroli (Eds.), Coordination Models and Languages - 17th IFIP WG 6.1 International  Conference, COORDINATION 2015, Held as Part of the 10th International  Federated Conference on Distributed Computing Techniques, DisCoTec  2015, Grenoble, France, June 2-4, 2015, Proceedings (Vol. 9037, pp. 213–229). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-19282-6_14</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1503.09097</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Programming Languages</tag>
		
	<tag>Transactional Memory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Transactional memory has arisen as a good way for solving many of the issues of lock-based programming. However, most implementations admit isolated transactions only, which are not adequate when we have to coordinate communicating processes. To this end, in this paper we present OCTM, an Haskell-like language with open transactions over shared transactional memory: processes can join transactions at runtime just by accessing to shared variables. Thus a transaction can co-operate with the environment through shared variables, but if it is rolled-back, also all its effects on the environment are retracted. For proving the expressive power of TCCS we give an implementation of TCCS, a CCS-like calculus with open transactions.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Mila Dalla Preda, Maurizio Gabbrielli, Saverio Giallorenzo, Ivan Lanese, &amp; Jacopo Mauro. (2015). &lt;span class=&quot;paper-title&quot;&gt;Developing correct, distributed, adaptive software&lt;/span&gt;. Sci. Comput. Program., 97, 41–46.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.scico.2013.11.019</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/scp2014/</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Adaptation</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<abstract>We illustrate our approach to develop and verify distributed, adaptive software systems. The cornerstone of our framework is the use of choreography languages, which allow us to obtain correctness by construction. Workflow Patterns are also used as abstract tools to design real systems, while techniques based on abstract interpretation and on dynamic verification are integrated in our framework to reduce the complexity of verification.</abstract>
</paper>
	
<paper>
	<year>2015</year>
	<content>Mila Dalla Preda, Maurizio Gabbrielli, Saverio Giallorenzo, Ivan Lanese, &amp; Jacopo Mauro. (2015). &lt;span class=&quot;paper-title&quot;&gt;Dynamic Choreographies - Safe Runtime Updates of Distributed Applications&lt;/span&gt;. In Coordination Models and Languages - 17th IFIP WG 6.1 International  Conference, COORDINATION 2015, Held as Part of the 10th International  Federated Conference on Distributed Computing Techniques, DisCoTec  2015, Grenoble, France, June 2-4, 2015, Proceedings (pp. 67–82). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-19282-6_5</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/dioc/</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Adaptation</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<abstract>Programming distributed applications free from communication deadlocks and races is complex. Preserving these properties when applications are updated at runtime is even harder. &lt;br /&gt; We present DIOC, a language for programming distributed applications that are free from deadlocks and races by construction. A DIOC program describes a whole distributed application as a unique entity (choreography). DIOC allows the programmer to specify which parts of the application can be updated. At runtime, these parts may be replaced by new DIOC fragments from outside the application. DIOC programs are compiled, generating code for each site, in a lower-level language called DPOC. We formalise both DIOC and DPOC semantics as labelled transition systems and prove the correctness of the compilation as a trace equivalence result. As corollaries, DPOC applications are free from communication deadlocks and races, even in presence of runtime updates.</abstract>
</paper>
	

	
<paper>
	<year>2014</year>
	<content>Luís Cruz-Filipe. (2014). &lt;span class=&quot;paper-title&quot;&gt;Optimizing Computation of Repairs from Active Integrity Constraints&lt;/span&gt;. In C. Beierle &amp; C. Meghini (Eds.), Foundations of Information and Knowledge Systems – 8th International Symposium, FoIKS 2014, Bordeaux, France, March 3-7, 2014. Proceedings (Vol. 8367, pp. 361–380). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-04939-7_18</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper13.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Active integrity constraints (AICs) are a form of integrity constraints for databases that not only identify inconsistencies, but also suggest how these can be overcome.  The semantics for AICs defines different types of repairs, but deciding whether an inconsistent database can be repaired and finding possible repairs is a NP- or &amp;Sigma;&lt;sup&gt;p&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;-complete problem, depending on the type of repairs one has in mind.  In this paper, we introduce two different relations on AICs: an equivalence relation of &lt;i&gt;independence&lt;/i&gt;, allowing the search to be parallelized among the equivalence classes, and a &lt;i&gt;precedence&lt;/i&gt; relation, inducing a stratification that allows repairs to be built progressively.  Although these relations have no impact on the worst-case scenario, they can make significant difference in the practical computation of repairs for inconsistent databases.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Michael Codish, Luís Cruz-Filipe, Michael Frank, &amp; Peter Schneider-Kamp. (2014). &lt;span class=&quot;paper-title&quot;&gt;Twenty-Five Comparators is Optimal when Sorting Nine Inputs (and Twenty-Nine for Ten)&lt;/span&gt;. In 26th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2014, Limassol, Cyprus, November 10–12, 2014 (pp. 186–193). IEEE.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1109/ICTAI.2014.36</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper17.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>This paper describes a computer-assisted non-existence proof of nine-input sorting networks consisting of 24 comparators, hence showing that the 25-comparator sorting network found by Floyd in 1964 is optimal. As a corollary, we obtain that the 29-comparator network found by Waksman in 1969 is optimal when sorting ten inputs.&lt;br /&gt;This closes the two smallest open instances of the optimal size sorting network problem, which have been open since the results of Floyd and Knuth from 1966 proving optimality for sorting networks of up to eight inputs.&lt;br /&gt;The proof involves a combination of two methodologies: one based on exploiting the abundance of symmetries in sorting networks, and the other, based on an encoding of the problem to that of satisfiability of propositional logic. We illustrate that, while each of these can single handed solve smaller instances of the problem, it is their combination which leads to an efficient solution for nine inputs.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Michael Codish, Luís Cruz-Filipe, &amp; Peter Schneider-Kamp. (2015). &lt;span class=&quot;paper-title&quot;&gt;The Quest for Optimal Sorting Networks: Efficient Generation of Two-Layer Prefixes&lt;/span&gt;. In F. Winkler, V. Negru, T. Ida, T. Jebelan, D. Petcu, S. M. Watt, &amp; D. Zaharie (Eds.), 16th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing, SYNASC 2014 (pp. 359–366). IEEE.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1109/SYNASC.2014.55</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper15.pdf</link>
	</link>
		
		
	<tag>Sorting Networks</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Previous work identifying depth-optimal &lt;i&gt;n&lt;/i&gt;-channel sorting networks for 9&amp;le;&lt;i&gt;n&lt;/i&gt;&amp;le;16 is based on exploiting symmetries of the first two layers.  However, the naive generate-and-test approach typically applied does not scale. This paper revisits the problem of generating two-layer prefixes modulo symmetries. An improved notion of symmetry is provided and a novel technique based on regular languages and graph isomorphism is shown to generate the set of non-symmetric representations.  An empirical evaluation demonstrates that the new method outperforms the generate-and-test approach by orders of magnitude and easily scales until &lt;i&gt;n&lt;/i&gt;=40.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Luís Cruz-Filipe, Graça Gaspar, &amp; Isabel Nunes. (2014). &lt;span class=&quot;paper-title&quot;&gt;Information Flow within Relational Multi-context Systems&lt;/span&gt;. In K. Janowicz, S. Schlobach, P. Lambrix, &amp; E. Hyvönen (Eds.), Knowledge Engineering and Knowledge Management – 19th International Conference, EKAW 2014, Linköping, Sweden, November 24–28, 2014. Proceedings (Vol. 8876, pp. 97–108). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-13704-9_8</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper16.pdf</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Multi-context systems (MCSs) are an important framework for heterogeneous combinations of systems within the Semantic Web. In this paper, we propose generic constructions to achieve specific forms of interaction in a principled way, and sistematize some useful techniques to work with ontologies within an MCS. All these mechanisms are presented in the form of general-purpose design patterns. Their study also suggests new ways in which this framework can be further extended.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Luís Cruz-Filipe, Ivan Lanese, Francisco Martins, António Ravara, &amp; Vasco T. Vasconcelos. (2014). &lt;span class=&quot;paper-title&quot;&gt;The Stream-based Service-Centered Calculus: a Foundation for Service-Oriented Programming&lt;/span&gt;. Formal Aspects of Computing, 26, 865–918.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/s00165-013-0284-5</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper14.pdf</link>
	</link>
		
		
	<tag>Process Calculi</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We give a formal account of SSCC, a calculus for modeling service-based systems, suitable to describe both service composition (orchestration) and the protocols that services follow when invoked (conversation). The calculus includes primitives for defining and invoking services, for isolating conversations (called sessions) among clients and servers, and for orchestrating services. The calculus is equipped with a reduction and a labeled transition semantics related by an equivalence result.&lt;br /&gt;SSCC provides a good trade-off between expressive power for modeling and simplicity for analysis. We assess the expressive power by modeling van der Aalst workflow patterns and an automotive case study from the European project Sensoria. For analysis, we present a simple type system ensuring compatibility of client and service protocols. We also study the behavioral theory of the calculus, highlighting some axioms that capture the behavior of the different primitives.&lt;br /&gt;As a final application of the theory, we define and prove correct some program transformations. These allow to start modeling a system from a typical UML Sequence Diagram, and then transform the specification to match the service-oriented programming style, thus simplifying its implementation using web services technology.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Marco Carbone, Fabrizio Montesi, &amp; Carsten Schürmann. (2014). &lt;span class=&quot;paper-title&quot;&gt;Choreographies, Logically&lt;/span&gt;. In P. Baldan &amp; D. Gorla (Eds.), CONCUR 2014 - Concurrency Theory - 25th International Conference,  CONCUR 2014, Rome, Italy, September 2-5, 2014. Proceedings (Vol. 8704, pp. 47–62). Springer.</content>
		
	<link>
		<name></name>
		<link>https://www.fabriziomontesi.com/files/cms14.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Logic</tag>
		
	<tag>Choreographic Programming</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Marco Carbone, Ornela Dardha, &amp; Fabrizio Montesi. (2014). &lt;span class=&quot;paper-title&quot;&gt;Progress as Compositional Lock-Freedom&lt;/span&gt;. In eva Kühn &amp; R. Pugliese (Eds.), Coordination Models and Languages - 16th IFIP WG 6.1 International  Conference, COORDINATION 2014, Held as Part of the 9th International  Federated Conferences on Distributed Computing Techniques, DisCoTec  2014, Berlin, Germany, June 3-5, 2014, Proceedings (Vol. 8459, pp. 49–64). Springer.</content>
		
	<link>
		<name></name>
		<link>https://www.fabriziomontesi.com/files/cdm14.pdf</link>
	</link>
		
		
	<tag>Session Types</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>A session-based process satisfies the progress property if its sessions never get stuck when it is executed in an adequate context. Previous work studied how to define progress by introducing the notion of catalysers, execution contexts generated from the type of a process. In this paper, we refine such definition to capture a more intuitive notion of context adequacy for checking progress. Interestingly, our new catalysers lead to a novel characterisation of progress in terms of the standard notion of lock-freedom. Guided by this discovery, we also develop a conservative extension of catalysers that does not depend on types, generalising the notion of progress to untyped session-based processes. We combine our results with existing techniques for lock-freedom, obtaining a new methodology for proving progress. Our methodology captures new processes wrt previous progress analysis based on session types.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Maurizio Gabbrielli, Saverio Giallorenzo, &amp; Fabrizio Montesi. (2014). &lt;span class=&quot;paper-title&quot;&gt;Service-Oriented Architectures: From Design to Production Exploiting  Workflow Patterns&lt;/span&gt;. In S. Omatu, H. Bersini, Rodrı́guez Juan M. Corchado, Rodrı́guez Sara, P. Pawlewski, &amp; E. Bucciarelli (Eds.), Distributed Computing and Artificial Intelligence, 11th International  Conference, DCAI 2014, Salamanca, Spain, June 4-6, 2014 (Vol. 290, pp. 131–139). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-07593-8_17</link>
	</link>
		
	<link>
		<name></name>
		<link>https://www.fabriziomontesi.com/files/ggm14.pdf</link>
	</link>
		
		
	<tag>Jolie</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<author>Saverio Giallorenzo</author>
		
	<abstract>In Service-Oriented Architectures (SOA), services are composed by coordinating their communications into a flow of interactions. Coloured Petri nets (CPN) offer a formal yet easy tool for modelling interactions in SOAs, however mapping abstract SOAs into executable ones requires a non-trivial and time-costly analysis. Here, we propose a methodology that maps CPN-modelled SOAs into Jolie SOAs (our target language), exploiting a collection of recurring control-flow patterns, called Workflow Patterns, as composable blocks of the translation. We validate our approach with a realistic use case. In addition, we pragmatically asses the expressiveness of Jolie wrt the considered WPs.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Alessio Mansutti, Marino Miculan, &amp; Marco Peressotti. (2014). &lt;span class=&quot;paper-title&quot;&gt;Distributed execution of bigraphical reactive systems&lt;/span&gt;. ECEASST, 71.</content>
		
	<link>
		<name>paper</name>
		<link>http://journal.ub.tu-berlin.de/eceasst/article/view/994</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1503.02434</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Rewriting Systems</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>The bigraph embedding problem is crucial for many results and tools about bigraphs and bigraphical reactive systems (BRS). Current algorithms for computing bigraphical embeddings are centralized, i.e. designed to run locally with a complete view of the guest and host bigraphs. In order to deal with large bigraphs, and to parallelize reactions, we present a decentralized algorithm, which distributes both state and computation over several concurrent processes. This allows for distributed, parallel simulations where non-interfering reactions can be carried out concurrently; nevertheless, even in the worst case the complexity of this distributed algorithm is no worse than that of a centralized algorithm.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Alessio Mansutti, Marino Miculan, &amp; Marco Peressotti. (2014). &lt;span class=&quot;paper-title&quot;&gt;Multi-agent Systems Design and Prototyping with Bigraphical Reactive  Systems&lt;/span&gt;. In K. Magoutis &amp; P. R. Pietzuch (Eds.), Distributed Applications and Interoperable Systems - 14th IFIP WG  6.1 International Conference, DAIS 2014, Held as Part of the 9th  International Federated Conference on Distributed Computing Techniques,  DisCoTec 2014, Berlin, Germany, June 3-5, 2014, Proceedings (Vol. 8460, pp. 201–208). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-662-43352-2_16</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Rewriting Systems</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>Several frameworks and methodologies have been proposed to ease the design of Multi Agent Systems (MAS), but the vast majority of them is tightly tied to specific implementation platforms. In this paper, we outline a methodology for MAS design and prototyping in the more abstract framework of Bigraphical Reactive Systems (BRS). In our approach, components and elements of the application domain are modelled as bigraphs, and their dynamics as graph rewriting rules. Desiderata can be encoded by means of type systems or logical formulae. Then, the BDI agents (i.e., their beliefs, desires and intentions) are identified and extracted from the BRS. This yield a prototype which can be run as distributed bigraphical system, evolving by means of distributed transactional rewritings triggered by cooperating agents depending on their internal intentions and beliefs. &lt;br/&gt; This methodology allows the designer to benefit from the results and tools from the theory of BRS, especially in the requirement analysis and validation phases. Among other results, we mention behavioural equivalences, temporal/spatial logics, visual tools for editing, for simulation and for model checking, etc. Moreover, bigraphs can be naturally composed, thus allowing for modular design of MAS.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Marino Miculan, &amp; Marco Peressotti. (2014). &lt;span class=&quot;paper-title&quot;&gt;GSOS for non-deterministic processes with quantitative aspects&lt;/span&gt;. In N. Bertrand &amp; L. Bortolussi (Eds.), Proceedings Twelfth International Workshop on Quantitative Aspects  of Programming Languages and Systems, QAPL 2014, Grenoble, France,  12-13 April 2014. (Vol. 154, pp. 17–33).</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.4204/EPTCS.154.2</link>
	</link>
		
	<link>
		<name>paper</name>
		<link>https://doi.org/10.4204/EPTCS.154.2</link>
	</link>
		
	<link>
		<name>technical report</name>
		<link>https://arxiv.org/abs/1410.0893</link>
	</link>
		
		
	<tag>Concurrency</tag>
		
	<tag>Coalgebras</tag>
		
	<tag>Quantitative Semantics</tag>
		
	<tag>Behavioural Theory</tag>
		
		
	<author>Marco Peressotti</author>
		
	<abstract>General frameworks have been recently proposed as unifying theories for processes combining non-determinism with quantitative aspects (such as probabilistic or stochastically timed executions), aiming to provide general results and tools. This paper provides two contributions in this respect. First, we present a general GSOS specification format and a corresponding notion of bisimulation for non-deterministic processes with quantitative aspects. These specifications define labelled transition systems according to the ULTraS model, an extension of the usual LTSs where the transition relation associates any source state and transition label with state reachability weight functions (like, e.g., probability distributions). This format, hence called Weight Function GSOS (WF-GSOS), covers many known systems and their bisimulations (e.g. PEPA, TIPP, PCSP) and GSOS formats (e.g. GSOS, Weighted GSOS, Segala-GSOS, among others). The second contribution is a characterization of these systems as coalgebras of a class of functors, parametric on the weight structure. This result allows us to prove soundness and completeness of the WF-GSOS specification format, and that bisimilarities induced by these specifications are always congruences.</abstract>
</paper>
	
<paper>
	<year>2014</year>
	<content>Mila Dalla Preda, Saverio Giallorenzo, Ivan Lanese, Jacopo Mauro, &amp; Maurizio Gabbrielli. (2014). &lt;span class=&quot;paper-title&quot;&gt;AIOCJ: A Choreographic Framework for Safe Adaptive Distributed  Applications&lt;/span&gt;. In Software Language Engineering - 7th International Conference, SLE  2014, Västerås, Sweden, September 15-16, 2014. Proceedings (pp. 161–170). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-319-11245-9_9</link>
	</link>
		
	<link>
		<name></name>
		<link>http://www.saveriogiallorenzo.com/publications/aiocj/</link>
	</link>
		
	<link>
		<name>website</name>
		<link>http://www.cs.unibo.it/projects/jolie/aiocj.html</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Adaptation</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Jacopo Mauro</author>
		
	<abstract>We present AIOCJ, a framework for programming distributed adaptive applications. Applications are programmed using AIOC, a choreographic language suited for expressing patterns of interaction from a global point of view. AIOC allows the programmer to specify which parts of the application can be adapted. Adaptation takes place at runtime by means of rules, which can change during the execution to tackle possibly unforeseen adaptation needs. AIOCJ relies on a solid theory that ensures applications to be deadlock-free by construction also after adaptation. We describe the architecture of AIOCJ, the design of the AIOC language, and an empirical validation of the framework.</abstract>
</paper>
	

	
<paper>
	<year>2013</year>
	<content>Luís Cruz-Filipe, Engrácia Patrı́cia, Graça Gaspar, &amp; Isabel Nunes. (2013). &lt;span class=&quot;paper-title&quot;&gt;Computing Repairs from Active Integrity Constraints&lt;/span&gt;. In H. Wang &amp; R. Banach (Eds.), 2013 International Symposium on Theoretical Aspects of Software Engineering, Birmingham, UK, July 1st–July 3rd 2013 (pp. 183–190). IEEE.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1109/TASE.2013.32</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper10.pdf</link>
	</link>
		
		
	<tag>Database Repair</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Repairing an inconsistent knowledge base is a well-known problem for which several solutions have been proposed and implemented in the past.  In this paper, we start by looking at databases with active integrity constraints &amp;ndash; consistency requirements that also indicate how the database should be updated when they are not met &amp;ndash; as introduced by Caroprese et al.  We show that the different kinds of repairs considered by those authors can be effectively computed by searching for leaves of specific kinds of trees.  Although these computations are in general not very efficient (deciding the existence of a repair for a given database with active integrity constraints is NP-complete), on average the algorithms we present make significant reductions on the number of nodes in the search tree.  Finally, these algorithms also give an operational characterization of different kinds of repairs that can be used when we extend the concept of active integrity constraints to the more general setting of knowledge bases.</abstract>
</paper>
	
<paper>
	<year>2013</year>
	<content>Luís Cruz-Filipe, Rita Henriques, &amp; Isabel Nunes. (2013). &lt;span class=&quot;paper-title&quot;&gt;Description Logics, Rules and Multi-context Systems&lt;/span&gt;. In K. L. McMillan, A. Middeldorp, &amp; A. Voronkov (Eds.), Logic for Programming, Artificial Intelligence, and Reasoning, 19th International Conference, LPAR-19, Stellenbosch, South Africa, December 2013, Proceedings (Vol. 8312, pp. 243–257). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-642-45221-5_18</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper12.pdf</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>The combination of rules and ontologies has been a fertile topic of research in the last years, with the proposal of several different systems that achieve this goal.  In this paper, we look at two of these mechanisms, Mdl-programs and multi-context systems, which address different aspects of this combination, and include different, incomparable programming constructs.  Despite this, we show that every Mdl-program can be transformed in a multi-context system, and this transformation relates the different semantics for each paradigm in a natural way.  As an application, we show how a set of design patterns for multi-context systems can be obtained from previous work on Mdl-programs.</abstract>
</paper>
	
<paper>
	<year>2013</year>
	<content>Luís Cruz-Filipe, Isabel Nunes, &amp; Graça Gaspar. (2013). &lt;span class=&quot;paper-title&quot;&gt;Patterns for Interfacing between Logic Programs and Multiple Ontologies&lt;/span&gt;. In J. Filipe &amp; J. Dietz (Eds.), KEOD 2013 Proceedings of the International Conference on Knowledge Engineering and Ontology Development, Vilamoura, Algarve, Portugal, 19-22 September, 2013 (pp. 58–69). SCITEPRESS.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.5220/0004544100580069</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper11.pdf</link>
	</link>
		
		
	<tag>Knowledge Representation</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Originally proposed in the mid-90s, design patterns for software development played a key role in object-oriented programming not only in increasing software quality, but also by giving a better understanding of the power and limitations of this paradigm.  Since then, several authors have endorsed a similar task for other programming paradigms, in the hope of achieving similar benefits.&lt;br /&gt;In this paper we discuss design patterns for hybrid semantic web systems combining several description logic knowledge bases via a logic program.  We introduce eight design patterns, grouped in three categories: three elementary patterns, which are the basic building blocks; four derived patterns, built from these; and a more complex pattern, the study of which can shed some insight in future syntactic developments of the underlying framework.  These patterns are extensively applied in a natural way in a large-scale example that illustrates how their usage greatly simplifies some programming tasks, at the level of both development and extension.&lt;br /&gt;We work in a generalization of dl-programs that supports several (possibly different) description logics, but the results presented are easily adaptable to other existing frameworks such as multi-context systems.</abstract>
</paper>
	

	
<paper>
	<year>2008</year>
	<content>Luís Cruz-Filipe, João Rasga, Sernadas Amı́lcar, &amp; Cristina Sernadas. (2008). &lt;span class=&quot;paper-title&quot;&gt;Complete Axiomatization of Discrete-Measure Almost-Everywhere Quantification&lt;/span&gt;. Journal of Logic and Computation, 18(6), 885–911.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1093/logcom/exn014</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper08.pdf</link>
	</link>
		
		
	<tag>Logic</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Following recent developments in the topic of generalized quantifiers, and also having in mind applications in the areas of security and artificial intelligence, a conservative enrichment of (two-sorted) first-order logic with almost-everywhere quantification is proposed. The completeness of the axiomatization against the measure-theoretic semantics is carried out using a variant of the Lindenbaum&amp;ndash;Henkin technique. The independence of the axioms is analyzed, and the almost-everywhere quantifier is compared with related notions of generalized quantification.</abstract>
</paper>
	
<paper>
	<year>2008</year>
	<content>Luís Cruz-Filipe, Ivan Lanese, Francisco Martins, António Ravara, &amp; Vasco T. Vasconcelos. (2008). &lt;span class=&quot;paper-title&quot;&gt;Behavioural Theory at Work: Program Transformations in a Service-Centred Calculus&lt;/span&gt;. In G. Barthe &amp; F. S. de Boer (Eds.), Proceedings of the 10th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems (FMOODS’08) (Vol. 5051, pp. 59–77). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-540-68863-1_5</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper09.pdf</link>
	</link>
		
		
	<tag>Process Calculi</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We analyse the relationship between object-oriented modelling and session-based, service-oriented modelling, starting from a typical UML Sequence Diagram and providing a program transformation into a service-oriented model.  We also provide a similar transformation from session-based specifications into request-response specifications.  All transformations are specified in SSCC &amp;ndash; a process calculus for modelling and analysing service-oriented systems &amp;ndash; and proved correct with respect to a suitable form of behavioural equivalence (full weak bisimilarity).  Since the equivalence is proved to be compositional, results remain valid in arbitrary contexts.</abstract>
</paper>
	
<paper>
	<year>2008</year>
	<content>Luís Cruz-Filipe, Sernadas Amı́lcar, &amp; Cristina Sernadas. (2008). &lt;span class=&quot;paper-title&quot;&gt;Heterogeneous Fibring of Deductive Systems via Abstract Proof Systems&lt;/span&gt;. Logic Journal of the IGPL, 16(2), 121–153.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1093/jigpal/jzm057</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper07.pdf</link>
	</link>
		
		
	<tag>Logic</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>Homogeneous fibring is a meta-logical constructor that produces new logics by combining logics presented in the same way (e.g. both of them endowed with an Hilbert calculus). Heterogeneous fibring (e.g. one of the logics is presented by an Hilbert calculus and the other by a sequent calculus) is an open problem that we solve now. We start by considering consequence systems as providing a solution (a good one when fibring a logic presented by semantic means and another one presented in a deductive way). However consequence systems are not good when we want to obtain as the result of fibring two deductive systems still a deductive system (where a notion of derivation appears in the fibring). The solution is to introduce the concept of (abstract) proof system. The fibring of proof systems is still a proof system and so we have that a derivation in the fibring is obtained from the derivations of the component. Some preservation results are discussed like compactness and semi-decidability.</abstract>
</paper>
	
<paper>
	<year>2008</year>
	<content>Claudio Guidi, Ivan Lanese, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2008). &lt;span class=&quot;paper-title&quot;&gt;On the interplay between fault handling and request-response service  invocations&lt;/span&gt;. In ACSD (pp. 190–198). IEEE.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/glmz08.pdf</link>
	</link>
		
		
	<tag>Jolie</tag>
		
	<tag>Microservices</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Service Oriented Computing (SOC) allows for the composition of services which communicate using unidirectional notification or bidirectional request-response primitives. Most service orchestration languages proposed so far provide also primitives to handle faults and compensations. The interplay between fault handling and request-response invocations is nontrivial since, for instance, faults should be notified to the requestresponse communication partners in order to compensate also the remote activities. Our work is motivated by the difficulties encountered in programming, using current orchestration languages, some fault handling strategies. We propose as a solution an orchestration programming style in which fault and compensation handlers are dynamically installed. We show the adequacy of our proposal defining its semantics, and proving that it satisfies some expected high-level properties. Finally, we also show how to apply dynamic handler installation in a nontrivial automotive scenario.</abstract>
</paper>
	
<paper>
	<year>2008</year>
	<content>Ivan Lanese, Claudio Guidi, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2008). &lt;span class=&quot;paper-title&quot;&gt;Bridging the Gap between Interaction- and Process-Oriented Choreographies&lt;/span&gt;. In SEFM (pp. 323–332). IEEE Computer Society.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/lgmz08.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>In service oriented computing, choreography languages are used to specify multi-party service compositions. Two main approaches have been followed: the interaction-oriented approach of WS-CDL and the process-oriented approach of BPEL4Chor. We investigate the relationship between them.In particular, we consider several interpretations for interaction-oriented choreographies spanning from synchronous to asynchronous communication. Under each of these interpretations we characterize the class of interaction-oriented choreographies which have a process-oriented counterpart, and we formalize the notion of equivalence between the initial interaction-oriented choreography and the corresponding process-oriented one.</abstract>
</paper>
	

	
<paper>
	<year>2007</year>
	<content>Rohit Chadha, Luís Cruz-Filipe, Paulo Mateus, &amp; Sernadas Amı́lcar. (2007). &lt;span class=&quot;paper-title&quot;&gt;Reasoning about Probabilistic Sequential Programs&lt;/span&gt;. Theoretical Computer Science, 379(1–2), 142–165.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.tcs.2007.02.040</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper06.pdf</link>
	</link>
		
		
	<tag>Logic</tag>
		
	<tag>Semantics</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>A complete and decidable Hoare-style calculus for iteration-free probabilistic sequential programs is presented using a state logic with truth-functional propositional (not arithmetical) connectives.</abstract>
</paper>
	
<paper>
	<year>2007</year>
	<content>Fabrizio Montesi, Claudio Guidi, &amp; Gianluigi Zavattaro. (2007). &lt;span class=&quot;paper-title&quot;&gt;Composing Services with JOLIE&lt;/span&gt;. In ECOWS (pp. 13–22). IEEE Computer Society.</content>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/mgz07.pdf</link>
	</link>
		
		
	<tag>Jolie</tag>
		
	<tag>Microservices</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Service composition and service statefulness are key concepts in Web Service system programming. In this paper we present JOLIE, which is the full implementation of our formal calculus for service orchestration called SOCK. JOLIE inherits all the formal semantics of SOCK and provides a C-like syntax which allows the programmer to design the service behaviour and the service deployment information separately. The service behaviour is exploited to design the interaction workflow and the computational functionalities of the service, whereas the service deployment information deals with service interface definition, statefulness and service session management. On the one hand, JOLIE offers a simple syntax for dealing with service composition and efficient multiple request processing; on the other hand, it is based on a formal semantics which offers a solid development base, along with the future possibility of creating automated tools for testing system properties such as deadlock freeness.</abstract>
</paper>
	
<paper>
	<year>2007</year>
	<content>Fabrizio Montesi, Claudio Guidi, Roberto Lucchi, &amp; Gianluigi Zavattaro. (2007). &lt;span class=&quot;paper-title&quot;&gt;JOLIE: a Java Orchestration Language Interpreter Engine&lt;/span&gt;. Electr. Notes Theor. Comput. Sci., 181, 19–33.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.entcs.2007.01.051</link>
	</link>
		
	<link>
		<name></name>
		<link>http://fabriziomontesi.com/files/mglz07.pdf</link>
	</link>
		
		
	<tag>Jolie</tag>
		
	<tag>Microservices</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Service oriented computing is an emerging paradigm for programming distributed applications based on services. Services are simple software elements that supply their functionalities by exhibiting their interfaces and that can be invoked by exploiting simple communication primitives. The emerging mechanism exploited in service oriented computing for composing services –in order to provide more complex functionalities by means of orchestrators. An orchestrator is able to invoke and coordinate other services by exploiting typical workflow patterns such as parallel composition, sequencing and choices. Examples of orchestration languages are XLANG and WS-BPEL. In this paper we present JOLIE, an interpreter and engine for orchestration programs. The main novelties of JOLIE are that it provides an easy to use development environment (because it supports a more programmer friendly C/Java-like syntax instead of an XML-based syntax) and it is based on a solid mathematical underlying model (developed in previous works of the authors).</abstract>
</paper>
	

	
<paper>
	<year>2006</year>
	<content>Luís Cruz-Filipe, &amp; Pierre Letouzey. (2006). &lt;span class=&quot;paper-title&quot;&gt;A Large-Scale Experiment in Executing Extracted Programs&lt;/span&gt;. Proceedings of the 12th Symposium on the Integration of Symbolic Computation and Mechanized Reasoning (Calculemus 2005), 151(1), 75–91.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1016/j.entcs.2005.11.024</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper05.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>It is a well-known fact that algorithms are often hidden inside mathematical proofs. If these proofs are formalized inside a proof assistant, then a mechanism called extraction can generate the corresponding programs automatically. Previous work has focused on the difficulties in obtaining a program from a formalization of the Fundamental Theorem of Algebra inside the Coq proof assistant. In theory, this program allows one to compute approximations of roots of polynomials. However, as we show in this work, there is currently a big gap between theory and practice. We study the complexity of the extracted program and analyze the reasons of its inefficiency, showing that this is a direct consequence of the approach used throughout the formalization.</abstract>
</paper>
	

	
<paper>
	<year>2004</year>
	<content>Luís Cruz-Filipe, Herman Geuvers, &amp; Freek Wiedijk. (2004). &lt;span class=&quot;paper-title&quot;&gt;C-CoRN: the Constructive Coq Repository at Nijmegen&lt;/span&gt;. In A. Asperti, G. Bancerek, &amp; A. Trybulec (Eds.), Mathematical Knowledge Management, Third International Conference, MKM 2004 (Vol. 3119, pp. 88–103). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-540-27818-4_7</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper04.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We present C-CoRN, the Constructive Coq Repository at Nijmegen. It consists of a library of constructive algebra and analysis, formalized in the theorem prover Coq. In this paper we explain the structure, the contents and the use of the library. Moreover we discuss the motivation and the (possible) applications of such a library.</abstract>
</paper>
	
<paper>
	<year>2004</year>
	<content>Luís Cruz-Filipe, &amp; Freek Wiedijk. (2004). &lt;span class=&quot;paper-title&quot;&gt;Hierarchical Reflection&lt;/span&gt;. In K. Slind, A. Bunker, &amp; G. Gopalakrishnan (Eds.), Theorem Proving in Higher Order Logics, 17th International Conference, TPHOLs 2004 (Vol. 3223, pp. 66–81). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/978-3-540-30142-4_5</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper03.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>The technique of reflection is a way to automate proof construction in type theoretical proof assistants. Reflection is based on the definition of a type of syntactic expressions that gets interpreted in the domain of discourse. By allowing the interpretation function to be partial or even a relation one gets a more general method known as &amp;quot;partial reflection&amp;quot;. In this paper we show how one can take advantage of the partiality of the interpretation to uniformly define a family of tactics for equational reasoning that will work in different algebraic structures. The tactics then follow the hierarchy of those algebraic structures in a natural way.</abstract>
</paper>
	

	
<paper>
	<year>2003</year>
	<content>Luís Cruz-Filipe. (2003). &lt;span class=&quot;paper-title&quot;&gt;A Constructive Formalization of the Fundamental Theorem of Calculus&lt;/span&gt;. In H. Geuvers &amp; F. Wiedijk (Eds.), Types for Proofs and Programs (Vol. 2646, pp. 108–126). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/3-540-39185-1_7</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper01.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>We have finished a constructive formalization in the theorem prover Coq of the Fundamental Theorem of Calculus, which states that differentiation and integration are inverse processes.  In this formalization, we have closely followed Bishop's work [1]. In this paper, we describe the formalization in some detail, focusing on how some of Bishop's original proofs had to be refined, adapted or redone from scratch.&lt;br /&gt;[1] Bishop, E., &lt;em&gt;Foundations of Constructive Analysis&lt;/em&gt;, McGraw-Hill Book Company, 1967.</abstract>
</paper>
	
<paper>
	<year>2003</year>
	<content>Luís Cruz-Filipe, &amp; Bas Spitters. (2003). &lt;span class=&quot;paper-title&quot;&gt;Program Extraction from Large Proof Developments&lt;/span&gt;. In D. A. Basin &amp; B. Wolff (Eds.), Theorem Proving in Higher Order Logics, 16th International Conference, TPHOLs 2003 (Vol. 2758, pp. 205–220). Springer.</content>
		
	<link>
		<name>doi</name>
		<link>https://doi.org/10.1007/10930755_14</link>
	</link>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/paper02.pdf</link>
	</link>
		
		
	<tag>Theorem Proving</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<abstract>It is well known that mathematical proofs often contain (abstract) algorithms, but although these algorithms can be understood by a human, it still takes a lot of time and effort to implement these algorithms on a computer; moreover, one runs the risk of making mistakes in the process.&lt;br /&gt;From a fully formalized constructive proof one can automatically obtain a computer implementation of such an algorithm together with a proof that the program is correct. As an example we consider the fundamental theorem of algebra which states that every non-constant polynomial has a root. This theorem has been fully formalized in the Coq proof assistant. Unfortunately, when we first tried to extract a program, the computer ran out of resources.&lt;br /&gt;We will discuss how we used logical techniques to make it possible to extract a feasible program. This example is used as a motivation for a broader perspective on how the formalization of mathematics should be done with program extraction in mind.</abstract>
</paper>
	

	
<paper>
	<year>Technical Reports</year>
	<content>Farhad Arbab, Luís Cruz-Filipe, Sung-Shik Jongmans, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;Connectors Meet Choreographies&lt;/span&gt;.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/subC.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by syntactically disallowing mismatched I/O and then synthesising process implementations automatically. Most choreography models assume that all communication occurs synchronously between two parties. This has been relaxed in some settings, allowing for example asynchronous communications, many-to-one, or one-to-many. However, these extensions are hardcoded in the syntax and semantics of each particular model.&lt;br /&gt;In this work, we present Cho-Reo-graphies (CR), a model where choreographies are parametric in the (Reo) connectors through which parties communicate. CR is the first choreography model where different communication semantics (e.g., synchronous and asynchronous) can freely be mixed in the same choreography. We prove that if a choreography respects the rules of the connectors that it uses, then the process implementation that we can synthesise from it enjoys deadlock freedom.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Marco Carbone, Luís Cruz-Filipe, Fabrizio Montesi, &amp; Agata Murawska. &lt;span class=&quot;paper-title&quot;&gt;Multiparty Classical Choreographies&lt;/span&gt;.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/subG.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>We present Multiparty Classical Choreographies (MCC), a language model where global descriptions of communicating systems (choreographies) and processes can be modularly composed to implement typed multiparty sessions. Typing is achieved by generalising classical linear logic to judgements that explicitly record parallelism by means of hypersequents. Our approach unifies different lines of work on choreographies and processes with multiparty sessions, as well as their connection to linear logic. Thus, results developed in one context are carried over to the others. Key novelties of MCC include support for behavioural polymorphism in choreographies, as well as a translation from processes with replication to choreographies.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;A Core Model for Choreographic Programming&lt;/span&gt;.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/subH.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.&lt;br /&gt;In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;Procedural Choreographic Programming&lt;/span&gt;.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/subA.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is an emerging paradigm for correct-by-construction concurrent programming based on message passing. Models based on choreographic programming have been successfully developed for different settings where concurrent programming is challenging, including service-oriented computing and cyber-physical systems. However, the general applicability of the paradigm is limited by the current lack of support for reusable procedures, which hinders modularity.&lt;br /&gt;We propose Procedural Choreographies (PC), a choreographic language model with full procedural abstraction. PC includes unbounded process creation and name mobility, yielding a powerful framework for writing correct concurrent algorithms that can be compiled into a process calculus. This expressivity requires a typing discipline to ensure that processes are properly connected when enacting procedures. Connections may form networks of arbitrary graph structures. We develop a formal synthesis procedure that, given a program in PC, generates a correct-by-construction concurrent implementation in terms of a process calculus. We illustrate the expressivity of PC with a series of examples, including parallel streams and parallel computation based on pipelining.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;On Asynchrony and Choreographies&lt;/span&gt;.</content>
		
	<link>
		<name></name>
		<link>http://tinyurl.com/lcfilipe/pubs/subD.pdf</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Luís Cruz-Filipe</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically and then correct-by-construction implementations in process models are mechanically generated. The formal semantics of choreography languages are typically based on synchronous communications, in order to achieve a simpler theory. However, many real-world systems have asynchronous communications. Previous attempts at enriching choreographies with asynchrony rely on &lt;i&gt;ad-hoc&lt;/i&gt; constructions, whose adequacy is only argued informally.&lt;br /&gt;In this work, we present a systematic study of asynchronous communications in choreographies. First, we discuss and formalise the properties that an asynchronous semantics for choreographies should have. Then, we explore how out-of-order execution, previously used in choreographies for modelling concurrency, can be used to endow choreographies with an asynchronous semantics that satisfies our properties. Our development yields a pleasant correspondence with FIFO-based asynchronous messaging, modelled in a process calculus. Finally, we investigate the expressivity of choreography languages with respect to asynchrony. Specifically, we find out that choreography languages equipped with process spawning and name mobility primitives are expressive enough to program asynchronous behaviour over a simple synchronous semantics.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Maurizio Gabbrielli, Saverio Giallorenzo, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Applied Choreographies&lt;/span&gt;. CoRR, abs/1510.03637.</content>
		
	<link>
		<name>technical report</name>
		<link>http://arxiv.org/abs/1510.03637</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Saverio Giallorenzo</author>
		
	<author>Fabrizio Montesi</author>
		
	<abstract>Choreographic Programming is a methodology for the development of concurrent software based on a correctness-by-construction approach which, given a global description of a system (a choreography), automatically generates deadlock-free communicating programs via an EndPoint Projection (EPP). Previous works use target-languages for EPP that, like their source choreography languages, model communications using channel names (e.g., variants of CCS and π-calculus). This leaves a gap between such models and real-world implementations, where communications are concretely supported by low-level mechanisms for message routing. We bridge this gap by developing Applied Choreographies (AC), a new model for choreographic programming. AC brings the correctness-by-construction methodology of choreographies down to the level of a real executable language. The key feature of AC is that its semantics is based on message correlation --- a standard technique in Service-Oriented Computing --- while retaining the usual simple and intuitive syntax of choreography languages. We provide AC with a typing discipline that ensures the correct use of the low-level mechanism of message correlation, thus avoiding communication errors. We also define a two-step compilation from AC to a low-level Correlation Calculus, which is the basis of a real executable language (Jolie). Finally, we prove an operational correspondence theorem, which ensures that compiled programs behave as the original choreography. This is the first result of such correctness property in the case of a real-world implemented language.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Fabrizio Montesi, &amp; Marco Peressotti. (2017). &lt;span class=&quot;paper-title&quot;&gt;Choreographies meet Communication Failures&lt;/span&gt;. CoRR, abs/1712.05465.</content>
		
	<link>
		<name></name>
		<link>https://arxiv.org/abs/1803.01049</link>
	</link>
		
		
	<tag>Choreographic Programming</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<author>Marco Peressotti</author>
		
	<abstract>Choreographies are global descriptions of communication structures, inspired by the &quot;Alice and Bob&quot; notation of security protocols. They have been successfully employed in the design and implementation of distributed systems. However, there is still limited evidence of the applicability of choreographies in the real-world setting of distributed programming, where communication actions may fail. In this work, we propose the first choreography model that allows for communication failures and the programming of user-defined code to deal with such failures. We validate our model by implementing common strategies for handling communication failures in a robust way, which in turn can be used as a library by choreographies that assume reliable communication. We equip our model with a typing discipline that can statically verify reliability properties, in particular at-most-once and exactly-once delivery. We demonstrate the applicability of our model by defining a semantics-preserving compilation procedure towards a process calculus equipped with unreliable I/O actions.</abstract>
</paper>
	
<paper>
	<year>Technical Reports</year>
	<content>Fabrizio Montesi, &amp; Marco Peressotti. (2018). &lt;span class=&quot;paper-title&quot;&gt;Classical Transitions&lt;/span&gt;. CoRR, abs/1803.01049.</content>
		
	<link>
		<name></name>
		<link>http://arxiv.org/abs/1803.01049</link>
	</link>
		
		
	<tag>Process Calculi</tag>
		
		
	<author>Fabrizio Montesi</author>
		
	<author>Marco Peressotti</author>
		
	<abstract>We introduce the calculus of Classical Transitions (CT), which extends the research line on the relationship between linear logic and processes to labelled transitions. The key twist from previous work is registering parallelism in typing judgements, by generalising linear logic judgements from one sequents to many (hypersequents). This allows us to bridge the gap between the structures of operators used as proof terms in previous work and those of the standard π-calculus (in particular parallel operator and restriction). The proof theory of CT allows for new proof transformations, which we show correspond to a labelled transition system (LTS) for processes. We prove that CT enjoys subject reduction and progress.</abstract>
</paper>
	

</papers>
