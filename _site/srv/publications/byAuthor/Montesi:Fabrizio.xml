<papers>

<collection>
	<title>Preprints of Accepted Papers</title>
		
			
		
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, Fabrizio Montesi, &amp; Marco Peressotti. &lt;span class=&quot;paper-title&quot;&gt;Communications in Choreographies, Revisited&lt;/span&gt;. Proceedings of the Symposium on Applied Computing, SAC 2018, Pau, France, April 9-13, 2018.</content>
			
		<link>
			<name>technical report</name>
			<link>https://arxiv.org/abs/1711.10201</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<author>Marco Peressotti</author>
			
		<abstract>Choreographic Programming is a paradigm for developing correct-by-construction concurrent programs, by writing high-level descriptions of the desired communications and then synthesising process implementations automatically. So far, choreographic programming has been explored in the &lt;i&gt;monadic&lt;/i&gt; setting: interaction terms express point-to-point communications of a single value. However, real-world systems often rely on interactions of &lt;i&gt;polyadic&lt;/i&gt; nature, where multiple values are communicated among two or more parties, like multicast, scatter-gather, and atomic exchanges.&lt;br /&gt;We introduce a new model for choreographic programming equipped with a primitive for grouped interactions that subsumes all the above scenarios. Intuitively, grouped interactions can be thought of as being carried out as one single interaction. In practice, they are implemented by processes that carry them out in a concurrent fashion. After formalising the intuitive semantics of grouped interactions, we prove that choreographic programs and their implementations are correct and deadlock-free by construction.</abstract>
		<bibitem>@unpublished{CMP18,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio and Peressotti, Marco},
  title = {Communications in Choreographies, Revisited},
  booktitle = {Proceedings of the Symposium on Applied Computing, {SAC} 2018, Pau, France, April 9-13, 2018},
  note = {accepted for publication}
}
</bibitem>
	</paper>
			
		
</collection>

<collection>
	<title>2018</title>
		
			
		
			
		
			
		
			
	<paper>
		<content>Marco Carbone, Fabrizio Montesi, &amp; Carsten Schürmann. (2018). &lt;span class=&quot;paper-title&quot;&gt;Choreographies, logically&lt;/span&gt;. Distributed Computing, 31(1), 51–67.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/s00446-017-0295-1</link>
		</link>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/cms18.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
		<tag>Process Calculi</tag>
			
		<tag>Logic</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.</abstract>
		<bibitem>@article{DBLP:journals/dc/CarboneMS18,
  author = {Carbone, Marco and Montesi, Fabrizio and Sch{\"{u}}rmann, Carsten},
  title = {Choreographies, logically},
  journal = {Distributed Computing},
  volume = {31},
  number = {1},
  pages = {51--67},
  year = {2018},
  url = {https://doi.org/10.1007/s00446-017-0295-1},
  doi = {10.1007/s00446-017-0295-1},
  timestamp = {Thu, 25 Jan 2018 11:13:07 +0100},
  biburl = {https://dblp.org/rec/bib/journals/dc/CarboneMS18},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Saverio Giallorenzo, Fabrizio Montesi, &amp; Maurizio Gabbrielli. (2018). &lt;span class=&quot;paper-title&quot;&gt;Applied Choreographies&lt;/span&gt;. In Formal Techniques for Distributed Objects, Components, and Systems  - 38th IFIP WG 6.1 International Conference, FORTE 2018, Held  as Part of the 13th International Federated Conference on Distributed  Computing Techniques, DisCoTec 2018, Madrid, Spain, June 18-21, 2018,  Proceedings (pp. 21–40). Springer.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/978-3-319-92612-4_2</link>
		</link>
			
		<link>
			<name></name>
			<link>http://www.saveriogiallorenzo.com/publications/forte2018/</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
		<tag>Session Types</tag>
			
			
		<author>Saverio Giallorenzo</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for distributed programming, where high-level &quot;Alice and Bob&quot; descriptions of communications (choreographies) are used to synthesise correct-by-construction programs. However, implementations of choreographic models use message routing technologies distant from their related theoretical models (e.g., CCS/π channels). This drives implementers to mediate discrepancies with the theory through undocumented, unproven adaptations, weakening the reliability of their implementations. As a solution, we propose the framework of Applied Choreographies (AC). In AC, programmers write choreographies in a language that follows the standard syntax and semantics of previous works. Then, choreographies are compiled to a real-world execution model for Service-Oriented Computing (SOC). To manage the complexity of this task, our compilation happens in three steps, respectively dealing with: implementing name-based communications using the concrete mechanism found in SOC, projecting a choreography to a set of processes, and translating processes to a distributed implementation in terms of services.</abstract>
		<bibitem>@inproceedings{GMG18,
  author = {Giallorenzo, Saverio and Montesi, Fabrizio and Gabbrielli, Maurizio},
  title = {Applied Choreographies},
  booktitle = {Formal Techniques for Distributed Objects, Components, and Systems  - 38th {IFIP} {WG} 6.1 International Conference, {FORTE} 2018, Held  as Part of the 13th International Federated Conference on Distributed  Computing Techniques, DisCoTec 2018, Madrid, Spain, June 18-21, 2018,  Proceedings},
  pages = {21--40},
  year = {2018},
  url = {https://doi.org/10.1007/978-3-319-92612-4_2},
  doi = {10.1007/978-3-319-92612-4_2},
  timestamp = {Wed, 30 May 2018 14:24:03 +0200},
  biburl = {https://dblp.org/rec/bib/conf/forte/GiallorenzoMG18},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  publisher = {Springer}
}
</bibitem>
	</paper>
			
		
</collection>

<collection>
	<title>2017</title>
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, Kim S. Larsen, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;The Paths to Choreography Extraction&lt;/span&gt;. In J. Esparza &amp; A. S. Murawski (Eds.), FoSSaCS (Vol. 10203, pp. 424–440). Springer.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper33.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographies are global descriptions of interactions among concurrent components, most notably used in the settings of verification (e.g., Multiparty Session Types) and synthesis of correct-by-construction software (Choreographic Programming).  They require a top-down approach: programmers first write choreographies, and then use them to verify or synthesize their programs.  However, most existing software does not come with choreographies yet, which prevents their application.&lt;br /&gt;To attack this problem, we propose a novel methodology (called choreography extraction) that, given a set of programs or protocol specifications, automatically constructs a choreography that describes their behavior. The key to our extraction is identifying a set of paths in a graph that represents the symbolic execution of the programs of interest. Our method improves on previous work in several directions: we can now deal with programs that are equipped with a state and internal computation capabilities; time complexity is dramatically better; we capture programs that are correct but not necessarily synchronizable, i.e., they work because they exploit asynchronous communication.</abstract>
		<bibitem>@inproceedings{CLM17,
  author = {Cruz{-}Filipe, Lu{\'i}s and Larsen, Kim S. and Montesi, Fabrizio},
  title = {The Paths to Choreography Extraction},
  editor = {Esparza, Javier and Murawski, Andrzej S.},
  series = {LNCS},
  booktitle = {FoSSaCS},
  volume = {10203},
  publisher = {Springer},
  year = {2017},
  pages = {424--440}
}
</bibitem>
	</paper>
			
		
			
		
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;A Core Model for Choreographic Programming&lt;/span&gt;. In O. Kouchnarenko &amp; R. Khosravi (Eds.), FACS (Vol. 10231, pp. 17–35). Springer.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper35.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.&lt;br /&gt;In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.</abstract>
		<bibitem>@inproceedings{CM17a,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {A Core Model for Choreographic Programming},
  publisher = {Springer},
  series = {LNCS},
  booktitle = {FACS},
  year = {2017},
  volume = {10231},
  pages = {17--35},
  editor = {Kouchnarenko, Olga and Khosravi, Ramin}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Encoding Asynchrony in Choreographies&lt;/span&gt;. In D. Shin &amp; M. Lencastre (Eds.), Proceedings of the Symposium on Applied Computing, SAC 2017, Marrakech, Morocco, April 3-7, 2017 (pp. 1175–1177).</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1145/3019612.3019901</link>
		</link>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper38.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographies are widely used for the specification of concurrent and distributed software architectures.  Since asynchronous communications are ubiquitous in real-world systems, previous works have proposed different approaches for the formal modelling of asynchrony in choreographies.  Such approaches typically rely on ad-hoc syntactic terms or semantics for capturing the concept of messages in transit, yielding different formalisms that have to be studied separately.&lt;br /&gt;In this work, we take a different approach, and show that such extensions are not needed to reason about asynchronous communications in choreographies. Rather, we demonstrate how a standard choreography calculus already has all the needed expressive power to encode messages in transit (and thus asynchronous communications) through the primitives of process spawning and name mobility.  The practical consequence of our results is that we can reason about real-world systems within a choreography formalism that is simpler than those hitherto proposed.</abstract>
		<bibitem>@inproceedings{CM17b,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {Encoding Asynchrony in Choreographies},
  editor = {Shin, D. and Lencastre, M.},
  pages = {1175--1177},
  booktitle = {Proceedings of the Symposium on Applied Computing, {SAC} 2017, Marrakech, Morocco, April 3-7, 2017},
  year = {2017},
  doi = {10.1145/3019612.3019901}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Procedural Choreographic Programming&lt;/span&gt;. In A. Bouajjani &amp; A. Silva (Eds.), Formal Techniques for Distributed Objects, Components, and Systems – 37th IFIP WG 6.1 International Conference, FORTE 2017 (Vol. 10321, pp. 92–107). Springer.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper39.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is an emerging paradigm for correct-by-construction concurrent programming. However, its applicability is limited by the current lack of support for reusable procedures.&lt;br /&gt;We propose Procedural Choreographies (PC), a choreographic language model with full procedural abstraction. PC includes unbounded process creation and name mobility, yielding a powerful framework for writing correct concurrent algorithms that can be compiled into a process calculus. This increased expressivity requires a typing discipline to ensure that processes are properly connected when enacting procedures.</abstract>
		<bibitem>@inproceedings{CM17c,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {Procedural Choreographic Programming},
  pages = {92--107},
  editor = {Bouajjani, Ahmed and Silva, Alexandra},
  booktitle = {Formal Techniques for Distributed Objects, Components, and Systems -- 37th IFIP WG 6.1 International Conference, FORTE 2017},
  series = {LNCS},
  publisher = {Springer},
  year = {2017},
  volume = {10321}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Cruz-Filipe Luı́s, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;That’s Enough: Asynchrony with Standard Choreography Primitives&lt;/span&gt;. In C. Caleiro, Dionı́sio Francisco, P. Gouveia, P. Mateus, &amp; J. Rasga (Eds.), Logic and Computation: Essays in Honour of Amı́lcar Sernadas (Vol. 33, pp. 125–142). College Publications.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper40.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographies are widely used for the specification of concurrent and distributed software architectures.  Since asynchronous communications are ubiquitous in real-world systems, previous works have proposed different approaches for the formal modelling of asynchrony in choreographies.  Such approaches typically rely on ad-hoc syntactic terms or semantics for capturing the concept of messages in transit, yielding different formalisms that have to be studied separately.&lt;br /&gt;In this work, we take a different approach, and show that such extensions are not needed to reason about asynchronous communications in choreographies. Rather, we demonstrate how a standard choreography calculus already has all the needed expressive power to encode messages in transit (and thus asynchronous communications) through the primitives of process spawning and name mobility.  The practical consequence of our results is that we can reason about real-world systems within a choreography formalism that is simpler than those hitherto proposed.</abstract>
		<bibitem>@incollection{CM17d,
  author = {Cruz-Filipe, Lu{\'\i}s and Montesi, Fabrizio},
  title = {That's Enough: Asynchrony with Standard Choreography Primitives},
  booktitle = {Logic and Computation: Essays in Honour of Am{\'\i}lcar Sernadas},
  editor = {Caleiro, Carlos and Dion{\'\i}sio, Francisco and Gouveia, Paula and Mateus, Paulo and Rasga, Jo{\~a}o},
  publisher = {College Publications},
  series = {Tributes},
  volume = {33},
  year = {2017},
  isbn = {978-1-84890-248-0},
  pages = {125--142}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;On Asynchrony and Choreographies&lt;/span&gt;. In M. Bartoletti, L. Bocchi, L. Henrio, &amp; S. Knight (Eds.), Proceedings 10th Interaction and Concurrency Experience (Vol. 261, pp. 76–90). Open Publishing Association.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.4204/EPTCS.261.8</link>
		</link>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper45.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically.  However, choreography languages are typically synchronous, whereas many real-world systems have asynchronous communications.  Previous attempts at enriching choreographies with asynchrony rely on &lt;i&gt;ad-hoc&lt;/i&gt; constructions, whose adequacy is only argued informally.  In this work, we formalise the properties that an asynchronous semantics for choreographies should have: messages can be sent without the intended receiver being ready, and all sent messages are eventually received.  We explore how out-of-order execution, used in choreographies for modelling concurrency, can be exploited to endow choreographies with an asynchronous semantics. Our approach satisfies the properties we identified.  We show how our development yields a pleasant correspondence with FIFO-based asynchronous messaging, modelled in a process calculus, and discuss how it can be adopted in more complex choreography models.</abstract>
		<bibitem>@incollection{CM17e,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {On Asynchrony and Choreographies},
  booktitle = {Proceedings 10th Interaction and Concurrency Experience},
  editor = {Bartoletti, M. and Bocchi, L. and Henrio, L. and Knight, S.},
  publisher = {Open Publishing Association},
  series = {EPTCS},
  volume = {261},
  year = {2017},
  pages = {76--90},
  doi = {10.4204/EPTCS.261.8}
}
</bibitem>
	</paper>
			
		
			
		
			
	<paper>
		<content>Marco Carbone, Fabrizio Montesi, Carsten Schürmann, &amp; Nobuko Yoshida. (2017). &lt;span class=&quot;paper-title&quot;&gt;Multiparty session types as coherence proofs&lt;/span&gt;. Acta Inf., 54(3), 243–269.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/cmsy16.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Logic</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence.</abstract>
		<bibitem>@article{CMSY17,
  author = {Carbone, Marco and Montesi, Fabrizio and Sch{\"{u}}rmann, Carsten and Yoshida, Nobuko},
  title = {Multiparty session types as coherence proofs},
  journal = {Acta Inf.},
  volume = {54},
  number = {3},
  pages = {243--269},
  year = {2017}
}
</bibitem>
	</paper>
			
		
			
		
			
	<paper>
		<content>Nicola Dragoni, Saverio Giallorenzo, Alberto Lluch Lafuente, Manuel Mazzara, Fabrizio Montesi, Ruslan Mustafin, &amp; Larisa Safina. (2017). &lt;span class=&quot;paper-title&quot;&gt;Microservices: yesterday, today, and tomorrow&lt;/span&gt;. In Present and Ulterior Software Engineering (pp. 195–216). Springer.</content>
			
		<link>
			<name></name>
			<link>http://www.saveriogiallorenzo.com/publications/msytt/</link>
		</link>
			
			
		<tag>Microservices</tag>
			
			
		<author>Saverio Giallorenzo</author>
			
		<author>Fabrizio Montesi</author>
			
		<author>Larisa Safina</author>
			
		<abstract>Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions.</abstract>
		<bibitem>@incollection{DGLMMMS17,
  title = {Microservices: yesterday, today, and tomorrow},
  author = {Dragoni, Nicola and Giallorenzo, Saverio and Lafuente, Alberto Lluch and Mazzara, Manuel and Montesi, Fabrizio and Mustafin, Ruslan and Safina, Larisa},
  booktitle = {Present and Ulterior Software Engineering},
  pages = {195--216},
  year = {2017},
  publisher = {Springer}
}
</bibitem>
	</paper>
			
		
			
		
			
	<paper>
		<content>Claudio Guidi, Ivan Lanese, Manuel Mazzara, &amp; Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Microservices: A Language-Based Approach&lt;/span&gt;. In Present and Ulterior Software Engineering (pp. 217–225). Springer.</content>
			
			
		<tag>Microservices</tag>
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Microservices is an emerging development paradigm where software is obtained by composing autonomous entities, called (micro)services. However, microservice systems are currently developed using general-purpose programming languages that do not provide dedicated abstractions for service composition. Instead, current practice is focused on the deployment aspects of microservices, in particular by using containerization. In this chapter, we make the case for a language-based approach to the engineering of microservice architectures, which we believe is complementary to current practice. We discuss the approach in general, and then we instantiate it in terms of the Jolie programming language.</abstract>
		<bibitem>@incollection{GLMM17,
  author = {Guidi, Claudio and Lanese, Ivan and Mazzara, Manuel and Montesi, Fabrizio},
  title = {Microservices: {A} Language-Based Approach},
  booktitle = {Present and Ulterior Software Engineering},
  pages = {217--225},
  publisher = {Springer},
  year = {2017}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi. (2017). &lt;span class=&quot;paper-title&quot;&gt;Classical Higher-Order Processes - (Short Paper)&lt;/span&gt;. In FORTE (Vol. 10321, pp. 171–178). Springer.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/m17_forte.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Logic</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Classical Processes (CP) is a calculus where the proof theory of classical linear logic types processes `a la π-calculus, building on a CurryHoward correspondence between session types and linear propositions. We contribute to this research line by extending CP with process mobility, inspired by the Higher-Order π-calculus. The key to our calculus is that sequents are asymmetric: one side types sessions as in CP and the other types process variables, which can be instantiated with process values. The controlled interaction between the two sides ensures that process variables can be used at will, but always respecting the linear usage of sessions expected by the environment.</abstract>
		<bibitem>@inproceedings{M17,
  author = {Montesi, Fabrizio},
  title = {Classical Higher-Order Processes - (Short Paper)},
  booktitle = {{FORTE}},
  series = {Lecture Notes in Computer Science},
  volume = {10321},
  pages = {171--178},
  publisher = {Springer},
  year = {2017}
}
</bibitem>
	</paper>
			
		
			
		
			
		
			
	<paper>
		<content>Fabrizio Montesi, &amp; Dan Sebastian Thrane. (2017). &lt;span class=&quot;paper-title&quot;&gt;Packaging Microservices - (Work in Progress)&lt;/span&gt;. In DAIS (Vol. 10320, pp. 131–137). Springer.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/mt17.pdf</link>
		</link>
			
			
		<tag>Microservices</tag>
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We describe a first proposal for a new packaging system for microservices based on the Jolie programming language, called the Jolie Package Manager (JPM). Its main features revolve around service interfaces, which make the functionalities that a service provides and depends on explicit. For the first time, JPM supports binding a service to an externally-provided package, and a notion of interface parametricity that can be used to develop generic service libraries that can modify the behaviour of arbitrary services. We illustrate the latter with a generic circuit breaker package.</abstract>
		<bibitem>@inproceedings{MT17,
  author = {Montesi, Fabrizio and Thrane, Dan Sebastian},
  title = {Packaging Microservices - (Work in Progress)},
  booktitle = {{DAIS}},
  series = {Lecture Notes in Computer Science},
  volume = {10320},
  pages = {131--137},
  publisher = {Springer},
  year = {2017}
}
</bibitem>
	</paper>
			
		
			
		
</collection>

<collection>
	<title>2016</title>
		
			
		
			
		
			
		
			
		
			
		
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Choreographies in Practice&lt;/span&gt;. In E. Albert &amp; I. Lanese (Eds.), Formal Techniques for Distributed Objects, Components, and Systems – 36th IFIP WG 6.1 International Conference, FORTE 2016 (Vol. 9688, pp. 114–123). Springer.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/978-3-319-39570-8_8</link>
		</link>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/paper27.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a development methodology for concurrent software that guarantees correctness by construction. The key to this paradigm is to disallow mismatched I/O operations in programs, and mechanically synthesise process implementations.&lt;br /&gt;There is still a lack of practical illustrations of the applicability of choreographies to computational problems with standard concurrent solutions. In this work, we explore the potential of choreographic programming by writing concurrent algorithms for sorting, solving linear equations, and computing Fast Fourier Transforms. The lessons learned from this experiment give directions for future improvements of the paradigm.</abstract>
		<bibitem>@inproceedings{CM16,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {Choreographies in Practice},
  pages = {114--123},
  doi = {10.1007/978-3-319-39570-8\_8},
  editor = {Albert, Elvira and Lanese, Ivan},
  booktitle = {Formal Techniques for Distributed Objects, Components, and Systems -- 36th IFIP WG 6.1 International Conference, FORTE 2016},
  series = {LNCS},
  volume = {9688},
  publisher = {Springer},
  year = {2016}
}
</bibitem>
	</paper>
			
		
			
		
			
	<paper>
		<content>Larisa Safina, Manuel Mazzara, Fabrizio Montesi, &amp; Rivera Vı́ctor. (2016). &lt;span class=&quot;paper-title&quot;&gt;Data-Driven Workflows for Microservices: Genericity in Jolie&lt;/span&gt;. In AINA (pp. 430–437). IEEE Computer Society.</content>
			
		<link>
			<name></name>
			<link>https://arxiv.org/abs/1511.02597</link>
		</link>
			
			
		<tag>Microservices</tag>
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<author>Larisa Safina</author>
			
		<abstract>Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Jolie is a programming language based on the microservices paradigm: the main building block of Jolie systems are services, in contrast to, e.g., functions or objects. The primitives offered by the Jolie language elicit many of the recurring patterns found in microservices, like load balancers and structured processes. However, Jolie still lacks some useful constructs for dealing with message types and data manipulation that are present in service-oriented computing. In this paper, we focus on the possibility of expressing choices at the level of data types, a feature well represented in standards for Web Services, e.g., WSDL. We extend Jolie to support such type choices and show the impact of our implementation on some of the typical scenarios found in microservice systems. This shows how computation can move from a process-driven to a data-driven approach, and leads to the preliminary identification of recurring communication patterns that can be shaped as design patterns.</abstract>
		<bibitem>@inproceedings{DBLP:conf/aina/SafinaMMR16,
  author = {Safina, Larisa and Mazzara, Manuel and Montesi, Fabrizio and Rivera, V{\'{\i}}ctor},
  title = {Data-Driven Workflows for Microservices: Genericity in Jolie},
  booktitle = {{AINA}},
  pages = {430--437},
  publisher = {{IEEE} Computer Society},
  year = {2016}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Marco Carbone, Sam Lindley, Fabrizio Montesi, Carsten Schürmann, &amp; Philip Wadler. (2016). &lt;span class=&quot;paper-title&quot;&gt;Coherence Generalises Duality: A Logical Explanation of Multiparty  Session Types&lt;/span&gt;. In CONCUR (Vol. 59, pp. 33:1–33:15). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.</content>
			
		<link>
			<name>publisher's website</name>
			<link>http://drops.dagstuhl.de/opus/volltexte/2016/6181/</link>
		</link>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/clmsw16.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Logic</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Wadler introduced Classical Processes (CP), a calculus based on a propositions-as-types correspondence between propositions of classical linear logic and session types. Carbone et al. introduced Multiparty Classical Processes, a calculus that generalises CP to multiparty session types, by replacing the duality of classical linear logic (relating two types) with a more general notion of coherence (relating an arbitrary number of types). This paper introduces variants of CP and MCP, plus a new intermediate calculus of Globally-governed Classical Processes (GCP). We show a tight relation between these three calculi, giving semantics-preserving translations from GCP to CP and from MCP to GCP. The translation from GCP to CP interprets a coherence proof as an arbiter process that mediates communications in a session, while MCP adds annotations that permit processes to communicate directly without centralised control.</abstract>
		<bibitem>@inproceedings{DBLP:conf/concur/CarboneLMSW16,
  author = {Carbone, Marco and Lindley, Sam and Montesi, Fabrizio and Sch{\"{u}}rmann, Carsten and Wadler, Philip},
  title = {Coherence Generalises Duality: {A} Logical Explanation of Multiparty  Session Types},
  booktitle = {{CONCUR}},
  series = {LIPIcs},
  volume = {59},
  pages = {33:1--33:15},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  year = {2016}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Davide Ancona, Viviana Bono, Mario Bravetti, Joana Campos, Giuseppe Castagna, Pierre-Malo Deniélou, … Nobuko Yoshida. (2016). &lt;span class=&quot;paper-title&quot;&gt;Behavioral Types in Programming Languages&lt;/span&gt;. Foundations and Trends in Programming Languages, 3(2-3), 95–230.</content>
			
		<link>
			<name>publisher's website</name>
			<link>https://www.nowpublishers.com/article/Details/PGL-031</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
		<tag>Session Types</tag>
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>A recent trend in programming language research is to use behavioral type theory to ensure various correctness properties of largescale, communication-intensive systems. Behavioral types encompass concepts such as interfaces, communication protocols, contracts, and choreography. The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account. This survey provides an overview of the state of the art of these aspects, which we summarize as the pragmatics of behavioral types.</abstract>
		<bibitem>@article{DBLP:journals/ftpl/AnconaBB0CDGGGH16,
  author = {Ancona, Davide and Bono, Viviana and Bravetti, Mario and Campos, Joana and Castagna, Giuseppe and Deni{\'{e}}lou, Pierre{-}Malo and Gay, Simon J. and Gesbert, Nils and Giachino, Elena and Hu, Raymond and Johnsen, Einar Broch and Martins, Francisco and Mascardi, Viviana and Montesi, Fabrizio and Neykova, Rumyana and Ng, Nicholas and Padovani, Luca and Vasconcelos, Vasco T. and Yoshida, Nobuko},
  title = {Behavioral Types in Programming Languages},
  journal = {Foundations and Trends in Programming Languages},
  volume = {3},
  number = {2-3},
  pages = {95--230},
  year = {2016}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Process-aware web programming with Jolie&lt;/span&gt;. Sci. Comput. Program., 130, 69–96.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/m16.pdf</link>
		</link>
			
			
		<tag>Microservices</tag>
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We extend the Jolie programming language to capture the native modelling of process-aware web information systems, i.e., web information systems based upon the execution of business processes. Our main contribution is to offer a unifying approach for the programming of distributed architectures on the web, which can capture web servers, stateful process execution, and the composition of services via mediation. We discuss applications of this approach through a series of examples that cover, e.g., static content serving, multiparty sessions, and the evolution of web systems. Finally, we present a performance evaluation that includes a comparison of Jolie-based web systems to other frameworks and a measurement of its scalability.</abstract>
		<bibitem>@article{DBLP:journals/scp/Montesi16,
  author = {Montesi, Fabrizio},
  title = {Process-aware web programming with Jolie},
  journal = {Sci. Comput. Program.},
  volume = {130},
  pages = {69--96},
  year = {2016}
}
</bibitem>
	</paper>
			
		
			
		
			
		
			
	<paper>
		<content>Maurizio Gabbrielli, Saverio Giallorenzo, Claudio Guidi, Jacopo Mauro, &amp; Fabrizio Montesi. (2016). &lt;span class=&quot;paper-title&quot;&gt;Self-Reconfiguring Microservices&lt;/span&gt;. In Theory and Practice of Formal Methods - Essays Dedicated to Frank  de Boer on the Occasion of His 60th Birthday (pp. 194–210). Springer.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/978-3-319-30734-3_14</link>
		</link>
			
		<link>
			<name></name>
			<link>http://www.saveriogiallorenzo.com/publications/self-reconfiguring/</link>
		</link>
			
			
		<tag>Microservices</tag>
			
		<tag>Optimisation</tag>
			
			
		<author>Saverio Giallorenzo</author>
			
		<author>Jacopo Mauro</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Microservices is an emerging paradigm for the development of distributed systems that, originating from Service-Oriented Architecture, focuses on the small dimension, the loose coupling, and the dynamic topology of services. Microservices are particularly appropriate for the development of distributed systems in the Cloud. However, their dynamic nature calls for suitable techniques for their automatic deployment. In this paper we address this problem and we propose JRO (Jolie Redeployment Optimiser), a tool for the automatic and optimised deployment of microservices written in the Jolie language. The tool uses Zephyrus, a state of the art tool that automatically generates a fully detailed Service-Oriented Architecture configuration starting from a partial and abstract description of the target application.</abstract>
		<bibitem>@inproceedings{GGGMM16,
  author = {Gabbrielli, Maurizio and Giallorenzo, Saverio and Guidi, Claudio and Mauro, Jacopo and Montesi, Fabrizio},
  title = {Self-Reconfiguring Microservices},
  booktitle = {Theory and Practice of Formal Methods - Essays Dedicated to Frank  de Boer on the Occasion of His 60th Birthday},
  pages = {194--210},
  year = {2016},
  url = {https://doi.org/10.1007/978-3-319-30734-3_14},
  doi = {10.1007/978-3-319-30734-3\_14},
  timestamp = {Thu, 15 Jun 2017 21:34:41 +0200},
  biburl = {https://dblp.org/rec/bib/conf/birthday/GabbrielliGGMM16},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  publisher = {Springer}
}
</bibitem>
	</paper>
			
		
			
		
			
		
</collection>

<collection>
	<title>2015</title>
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
	<paper>
		<content>Marco Carbone, Fabrizio Montesi, Carsten Schürmann, &amp; Nobuko Yoshida. (2015). &lt;span class=&quot;paper-title&quot;&gt;Multiparty Session Types as Coherence Proofs&lt;/span&gt;. In L. Aceto &amp; D. de Frutos-Escrig (Eds.), 26th International Conference on Concurrency Theory, CONCUR 2015,  Madrid, Spain, September 1.4, 2015 (Vol. 42, pp. 412–426). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.4230/LIPIcs.CONCUR.2015.412</link>
		</link>
			
		<link>
			<name></name>
			<link>https://www.fabriziomontesi.com/files/cmsy15.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Logic</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence.</abstract>
		<bibitem>@inproceedings{DBLP:conf/concur/CarboneMSY15,
  author = {Carbone, Marco and Montesi, Fabrizio and Sch{\"{u}}rmann, Carsten and Yoshida, Nobuko},
  editor = {Aceto, Luca and de Frutos{-}Escrig, David},
  title = {Multiparty Session Types as Coherence Proofs},
  booktitle = {26th International Conference on Concurrency Theory, {CONCUR} 2015,  Madrid, Spain, September 1.4, 2015},
  series = {LIPIcs},
  volume = {42},
  pages = {412--426},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  year = {2015},
  url = {https://doi.org/10.4230/LIPIcs.CONCUR.2015.412},
  doi = {10.4230/LIPIcs.CONCUR.2015.412}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Kickstarting Choreographic Programming&lt;/span&gt;. In T. T. Hildebrandt, A. Ravara, J. M. van der Werf, &amp; M. Weidlich (Eds.), Web Services, Formal Methods, and Behavioral Types - 11th International  Workshop, WS-FM 2014, Eindhoven, The Netherlands, September 11-12,  2014, and 12th International Workshop, WS-FM/BEAT 2015, Madrid,  Spain, September 4-5, 2015, Revised Selected Papers (Vol. 9421, pp. 3–10). Springer.</content>
			
		<link>
			<name></name>
			<link>http://arxiv.org/abs/1502.02519</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We present an overview of some recent efforts aimed at the development of Choreographic Programming, a programming paradigm for the production of concurrent software that is guaranteed to be correct by construction from global descriptions of communication behaviour.</abstract>
		<bibitem>@inproceedings{DBLP:conf/wsfm/Montesi15,
  author = {Montesi, Fabrizio},
  editor = {Hildebrandt, Thomas T. and Ravara, Ant{\'{o}}nio and van der Werf, Jan Martijn and Weidlich, Matthias},
  title = {Kickstarting Choreographic Programming},
  booktitle = {Web Services, Formal Methods, and Behavioral Types - 11th International  Workshop, {WS-FM} 2014, Eindhoven, The Netherlands, September 11-12,  2014, and 12th International Workshop, {WS-FM/BEAT} 2015, Madrid,  Spain, September 4-5, 2015, Revised Selected Papers},
  series = {Lecture Notes in Computer Science},
  volume = {9421},
  pages = {3--10},
  publisher = {Springer},
  year = {2015},
  url = {https://doi.org/10.1007/978-3-319-33612-1_1}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Mario Bravetti, Alberto Lluch-Lafuente, Manuel Mazzara, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Guest Editorial: Special Issue on Service-Oriented Architectures and  Programming&lt;/span&gt;. J. Internet Serv. Inf. Secur., 5(1), 1–2.</content>
			
		<link>
			<name>paper</name>
			<link>http://isyou.info/jisis/vol5/no1/jisis-2015-vol5-no1-00.pdf</link>
		</link>
			
			
		<tag>Service-Oriented Computing</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract></abstract>
		<bibitem>@article{DBLP:journals/jisis/BravettiLMM15,
  author = {Bravetti, Mario and Lluch{-}Lafuente, Alberto and Mazzara, Manuel and Montesi, Fabrizio},
  title = {Guest Editorial: Special Issue on Service-Oriented Architectures and  Programming},
  journal = {J. Internet Serv. Inf. Secur.},
  volume = {5},
  number = {1},
  pages = {1--2},
  year = {2015},
  url = {http://isyou.info/jisis/vol5/no1/jisis-2015-vol5-no1-00.pdf}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Ivan Lanese, Manuel Mazzara, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Special issue on Service-Oriented Architecture and Programming (SOAP  2013)&lt;/span&gt;. Sci. Comput. Program., 97, 181–182.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1016/j.scico.2014.07.007</link>
		</link>
			
		<link>
			<name>paper</name>
			<link>https://doi.org/10.1016/j.scico.2014.07.007</link>
		</link>
			
			
		<tag>Service-Oriented Computing</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract></abstract>
		<bibitem>@article{DBLP:journals/scp/LaneseMM15,
  author = {Lanese, Ivan and Mazzara, Manuel and Montesi, Fabrizio},
  title = {Special issue on Service-Oriented Architecture and Programming {(SOAP}  2013)},
  journal = {Sci. Comput. Program.},
  volume = {97},
  pages = {181--182},
  year = {2015},
  url = {https://doi.org/10.1016/j.scico.2014.07.007},
  doi = {10.1016/j.scico.2014.07.007}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Ivan Lanese, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2015). &lt;span class=&quot;paper-title&quot;&gt;The Evolution of Jolie - From Orchestrations to Adaptable Choreographies&lt;/span&gt;. In R. D. Nicola &amp; R. Hennicker (Eds.), Software, Services, and Systems - Essays Dedicated to Martin Wirsing  on the Occasion of His Retirement from the Chair of Programming and  Software Engineering (Vol. 8950, pp. 506–521). Springer.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/978-3-319-15545-6_29</link>
		</link>
			
		<link>
			<name></name>
			<link>https://www.fabriziomontesi.com/files/lmz15.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
		<tag>Choreographic Programming</tag>
			
		<tag>Adaptation</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Jolie is an orchestration language conceived during Sensoria, an FP7 European project led by Martin Wirsing in the time frame 2005–2010. Jolie was designed having in mind both the novel –at project time– concepts related to Service-Oriented Computing and the traditional approach to the modelling of concurrency typical of process calculi. The foundational work done around Jolie during Sensoria has subsequently produced many concrete results. In this paper we focus on two distinct advancements, one aiming at the development of dynamically adaptable orchestrated systems and one focusing on global choreographic specifications. These works, more recently, contributed to the realisation of a framework for programming dynamically evolvable distributed ServiceOriented applications that are correct-by-construction</abstract>
		<bibitem>@inproceedings{LMZ15,
  author = {Lanese, Ivan and Montesi, Fabrizio and Zavattaro, Gianluigi},
  editor = {Nicola, Rocco De and Hennicker, Rolf},
  title = {The Evolution of Jolie - From Orchestrations to Adaptable Choreographies},
  booktitle = {Software, Services, and Systems - Essays Dedicated to Martin Wirsing  on the Occasion of His Retirement from the Chair of Programming and  Software Engineering},
  series = {Lecture Notes in Computer Science},
  volume = {8950},
  pages = {506--521},
  publisher = {Springer},
  year = {2015},
  url = {https://doi.org/10.1007/978-3-319-15545-6_29},
  doi = {10.1007/978-3-319-15545-6_29}
}
</bibitem>
	</paper>
			
		
			
		
			
		
			
		
</collection>

<collection>
	<title>2014</title>
		
			
		
			
		
			
		
			
		
			
		
			
	<paper>
		<content>Marco Carbone, Fabrizio Montesi, &amp; Carsten Schürmann. (2014). &lt;span class=&quot;paper-title&quot;&gt;Choreographies, Logically&lt;/span&gt;. In P. Baldan &amp; D. Gorla (Eds.), CONCUR 2014 - Concurrency Theory - 25th International Conference,  CONCUR 2014, Rome, Italy, September 2-5, 2014. Proceedings (Vol. 8704, pp. 47–62). Springer.</content>
			
		<link>
			<name></name>
			<link>https://www.fabriziomontesi.com/files/cms14.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Logic</tag>
			
		<tag>Choreographic Programming</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.</abstract>
		<bibitem>@inproceedings{DBLP:conf/concur/CarboneMS14,
  author = {Carbone, Marco and Montesi, Fabrizio and Sch{\"{u}}rmann, Carsten},
  editor = {Baldan, Paolo and Gorla, Daniele},
  title = {Choreographies, Logically},
  booktitle = {{CONCUR} 2014 - Concurrency Theory - 25th International Conference,  {CONCUR} 2014, Rome, Italy, September 2-5, 2014. Proceedings},
  series = {Lecture Notes in Computer Science},
  volume = {8704},
  pages = {47--62},
  publisher = {Springer},
  year = {2014}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Marco Carbone, Ornela Dardha, &amp; Fabrizio Montesi. (2014). &lt;span class=&quot;paper-title&quot;&gt;Progress as Compositional Lock-Freedom&lt;/span&gt;. In eva Kühn &amp; R. Pugliese (Eds.), Coordination Models and Languages - 16th IFIP WG 6.1 International  Conference, COORDINATION 2014, Held as Part of the 9th International  Federated Conferences on Distributed Computing Techniques, DisCoTec  2014, Berlin, Germany, June 3-5, 2014, Proceedings (Vol. 8459, pp. 49–64). Springer.</content>
			
		<link>
			<name></name>
			<link>https://www.fabriziomontesi.com/files/cdm14.pdf</link>
		</link>
			
			
		<tag>Session Types</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>A session-based process satisfies the progress property if its sessions never get stuck when it is executed in an adequate context. Previous work studied how to define progress by introducing the notion of catalysers, execution contexts generated from the type of a process. In this paper, we refine such definition to capture a more intuitive notion of context adequacy for checking progress. Interestingly, our new catalysers lead to a novel characterisation of progress in terms of the standard notion of lock-freedom. Guided by this discovery, we also develop a conservative extension of catalysers that does not depend on types, generalising the notion of progress to untyped session-based processes. We combine our results with existing techniques for lock-freedom, obtaining a new methodology for proving progress. Our methodology captures new processes wrt previous progress analysis based on session types.</abstract>
		<bibitem>@inproceedings{DBLP:conf/coordination/CarboneDM14,
  author = {Carbone, Marco and Dardha, Ornela and Montesi, Fabrizio},
  editor = {eva K{\"{u}}hn and Pugliese, Rosario},
  title = {Progress as Compositional Lock-Freedom},
  booktitle = {Coordination Models and Languages - 16th {IFIP} {WG} 6.1 International  Conference, {COORDINATION} 2014, Held as Part of the 9th International  Federated Conferences on Distributed Computing Techniques, DisCoTec  2014, Berlin, Germany, June 3-5, 2014, Proceedings},
  series = {Lecture Notes in Computer Science},
  volume = {8459},
  pages = {49--64},
  publisher = {Springer},
  year = {2014}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Maurizio Gabbrielli, Saverio Giallorenzo, &amp; Fabrizio Montesi. (2014). &lt;span class=&quot;paper-title&quot;&gt;Service-Oriented Architectures: From Design to Production Exploiting  Workflow Patterns&lt;/span&gt;. In S. Omatu, H. Bersini, Rodrı́guez Juan M. Corchado, Rodrı́guez Sara, P. Pawlewski, &amp; E. Bucciarelli (Eds.), Distributed Computing and Artificial Intelligence, 11th International  Conference, DCAI 2014, Salamanca, Spain, June 4-6, 2014 (Vol. 290, pp. 131–139). Springer.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1007/978-3-319-07593-8_17</link>
		</link>
			
		<link>
			<name></name>
			<link>https://www.fabriziomontesi.com/files/ggm14.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<author>Saverio Giallorenzo</author>
			
		<abstract>In Service-Oriented Architectures (SOA), services are composed by coordinating their communications into a flow of interactions. Coloured Petri nets (CPN) offer a formal yet easy tool for modelling interactions in SOAs, however mapping abstract SOAs into executable ones requires a non-trivial and time-costly analysis. Here, we propose a methodology that maps CPN-modelled SOAs into Jolie SOAs (our target language), exploiting a collection of recurring control-flow patterns, called Workflow Patterns, as composable blocks of the translation. We validate our approach with a realistic use case. In addition, we pragmatically asses the expressiveness of Jolie wrt the considered WPs.</abstract>
		<bibitem>@inproceedings{DBLP:conf/dcai/GabbrielliGM14,
  author = {Gabbrielli, Maurizio and Giallorenzo, Saverio and Montesi, Fabrizio},
  editor = {Omatu, Sigeru and Bersini, Hugues and Rodr{\'{\i}}guez, Juan M. Corchado and Rodr{\'{\i}}guez, Sara and Pawlewski, Pawel and Bucciarelli, Edgardo},
  title = {Service-Oriented Architectures: From Design to Production Exploiting  Workflow Patterns},
  booktitle = {Distributed Computing and Artificial Intelligence, 11th International  Conference, {DCAI} 2014, Salamanca, Spain, June 4-6, 2014},
  series = {Advances in Intelligent Systems and Computing},
  volume = {290},
  pages = {131--139},
  publisher = {Springer},
  year = {2014},
  url = {https://doi.org/10.1007/978-3-319-07593-8_17},
  doi = {10.1007/978-3-319-07593-8_17}
}
</bibitem>
	</paper>
			
		
			
		
			
		
			
		
			
		
</collection>

<collection>
	<title>2013</title>
		
			
		
			
		
			
		
</collection>

<collection>
	<title>2008</title>
		
			
		
			
		
			
		
			
	<paper>
		<content>Claudio Guidi, Ivan Lanese, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2008). &lt;span class=&quot;paper-title&quot;&gt;On the interplay between fault handling and request-response service  invocations&lt;/span&gt;. In ACSD (pp. 190–198). IEEE.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/glmz08.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
		<tag>Microservices</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Service Oriented Computing (SOC) allows for the composition of services which communicate using unidirectional notification or bidirectional request-response primitives. Most service orchestration languages proposed so far provide also primitives to handle faults and compensations. The interplay between fault handling and request-response invocations is nontrivial since, for instance, faults should be notified to the requestresponse communication partners in order to compensate also the remote activities. Our work is motivated by the difficulties encountered in programming, using current orchestration languages, some fault handling strategies. We propose as a solution an orchestration programming style in which fault and compensation handlers are dynamically installed. We show the adequacy of our proposal defining its semantics, and proving that it satisfies some expected high-level properties. Finally, we also show how to apply dynamic handler installation in a nontrivial automotive scenario.</abstract>
		<bibitem>@inproceedings{DBLP:conf/acsd/GuidiLMZ08,
  author = {Guidi, Claudio and Lanese, Ivan and Montesi, Fabrizio and Zavattaro, Gianluigi},
  title = {On the interplay between fault handling and request-response service  invocations},
  booktitle = {{ACSD}},
  pages = {190--198},
  publisher = {{IEEE}},
  year = {2008}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi, Claudio Guidi, Ivan Lanese, &amp; Gianluigi Zavattaro. (2008). &lt;span class=&quot;paper-title&quot;&gt;Dynamic Fault Handling Mechanisms for Service-Oriented Applications&lt;/span&gt;. In C. Pahl, S. Clarke, &amp; R. Eshuis (Eds.), ECOWS 2008, Sixth European Conference on Web Services, 12-14 November  2008, Dublin, Ireland (pp. 225–234). IEEE Computer Society.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1109/ECOWS.2008.20</link>
		</link>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/mglz08.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
		<tag>Microservices</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Dynamic fault handling is a new approach for dealing with fault management in service-oriented applications. Fault handlers, termination handlers and compensation handlers are installed at execution time instead of being statically defined. In this paper we present this programming style and our implementation of dynamic fault handling in JOLIE, providing finally a nontrivial example of its usage.</abstract>
		<bibitem>@inproceedings{DBLP:conf/ecows/MontesiGLZ08,
  author = {Montesi, Fabrizio and Guidi, Claudio and Lanese, Ivan and Zavattaro, Gianluigi},
  editor = {Pahl, Claus and Clarke, Siobh{\'{a}}n and Eshuis, Rik},
  title = {Dynamic Fault Handling Mechanisms for Service-Oriented Applications},
  booktitle = {{ECOWS} 2008, Sixth European Conference on Web Services, 12-14 November  2008, Dublin, Ireland},
  pages = {225--234},
  publisher = {{IEEE} Computer Society},
  year = {2008},
  url = {https://doi.org/10.1109/ECOWS.2008.20},
  doi = {10.1109/ECOWS.2008.20}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Ivan Lanese, Claudio Guidi, Fabrizio Montesi, &amp; Gianluigi Zavattaro. (2008). &lt;span class=&quot;paper-title&quot;&gt;Bridging the Gap between Interaction- and Process-Oriented Choreographies&lt;/span&gt;. In SEFM (pp. 323–332). IEEE Computer Society.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/lgmz08.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>In service oriented computing, choreography languages are used to specify multi-party service compositions. Two main approaches have been followed: the interaction-oriented approach of WS-CDL and the process-oriented approach of BPEL4Chor. We investigate the relationship between them.In particular, we consider several interpretations for interaction-oriented choreographies spanning from synchronous to asynchronous communication. Under each of these interpretations we characterize the class of interaction-oriented choreographies which have a process-oriented counterpart, and we formalize the notion of equivalence between the initial interaction-oriented choreography and the corresponding process-oriented one.</abstract>
		<bibitem>@inproceedings{DBLP:conf/sefm/LaneseGMZ08,
  author = {Lanese, Ivan and Guidi, Claudio and Montesi, Fabrizio and Zavattaro, Gianluigi},
  title = {Bridging the Gap between Interaction- and Process-Oriented Choreographies},
  booktitle = {{SEFM}},
  pages = {323--332},
  publisher = {{IEEE} Computer Society},
  year = {2008}
}
</bibitem>
	</paper>
			
		
</collection>

<collection>
	<title>2007</title>
		
			
		
			
	<paper>
		<content>Fabrizio Montesi, Claudio Guidi, &amp; Gianluigi Zavattaro. (2007). &lt;span class=&quot;paper-title&quot;&gt;Composing Services with JOLIE&lt;/span&gt;. In ECOWS (pp. 13–22). IEEE Computer Society.</content>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/mgz07.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
		<tag>Microservices</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Service composition and service statefulness are key concepts in Web Service system programming. In this paper we present JOLIE, which is the full implementation of our formal calculus for service orchestration called SOCK. JOLIE inherits all the formal semantics of SOCK and provides a C-like syntax which allows the programmer to design the service behaviour and the service deployment information separately. The service behaviour is exploited to design the interaction workflow and the computational functionalities of the service, whereas the service deployment information deals with service interface definition, statefulness and service session management. On the one hand, JOLIE offers a simple syntax for dealing with service composition and efficient multiple request processing; on the other hand, it is based on a formal semantics which offers a solid development base, along with the future possibility of creating automated tools for testing system properties such as deadlock freeness.</abstract>
		<bibitem>@inproceedings{DBLP:conf/ecows/MontesiGZ07,
  author = {Montesi, Fabrizio and Guidi, Claudio and Zavattaro, Gianluigi},
  title = {Composing Services with {JOLIE}},
  booktitle = {{ECOWS}},
  pages = {13--22},
  publisher = {{IEEE} Computer Society},
  year = {2007}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi, Claudio Guidi, Roberto Lucchi, &amp; Gianluigi Zavattaro. (2007). &lt;span class=&quot;paper-title&quot;&gt;JOLIE: a Java Orchestration Language Interpreter Engine&lt;/span&gt;. Electr. Notes Theor. Comput. Sci., 181, 19–33.</content>
			
		<link>
			<name>doi</name>
			<link>https://doi.org/10.1016/j.entcs.2007.01.051</link>
		</link>
			
		<link>
			<name></name>
			<link>http://fabriziomontesi.com/files/mglz07.pdf</link>
		</link>
			
			
		<tag>Jolie</tag>
			
		<tag>Microservices</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Service oriented computing is an emerging paradigm for programming distributed applications based on services. Services are simple software elements that supply their functionalities by exhibiting their interfaces and that can be invoked by exploiting simple communication primitives. The emerging mechanism exploited in service oriented computing for composing services –in order to provide more complex functionalities by means of orchestrators. An orchestrator is able to invoke and coordinate other services by exploiting typical workflow patterns such as parallel composition, sequencing and choices. Examples of orchestration languages are XLANG and WS-BPEL. In this paper we present JOLIE, an interpreter and engine for orchestration programs. The main novelties of JOLIE are that it provides an easy to use development environment (because it supports a more programmer friendly C/Java-like syntax instead of an XML-based syntax) and it is based on a solid mathematical underlying model (developed in previous works of the authors).</abstract>
		<bibitem>@article{DBLP:journals/entcs/MontesiGLZ07,
  author = {Montesi, Fabrizio and Guidi, Claudio and Lucchi, Roberto and Zavattaro, Gianluigi},
  title = {{JOLIE:} a Java Orchestration Language Interpreter Engine},
  journal = {Electr. Notes Theor. Comput. Sci.},
  volume = {181},
  pages = {19--33},
  year = {2007},
  url = {https://doi.org/10.1016/j.entcs.2007.01.051},
  doi = {10.1016/j.entcs.2007.01.051},
  timestamp = {Mon, 05 Jun 2017 20:49:21 +0200},
  biburl = {https://dblp.org/rec/bib/journals/entcs/MontesiGLZ07},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
</bibitem>
	</paper>
			
		
</collection>

<collection>
	<title>2006</title>
		
			
		
</collection>

<collection>
	<title>2004</title>
		
			
		
			
		
</collection>

<collection>
	<title>2003</title>
		
			
		
			
		
</collection>

<collection>
	<title>Technical Reports</title>
		
			
	<paper>
		<content>Farhad Arbab, Luís Cruz-Filipe, Sung-Shik Jongmans, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;Connectors Meet Choreographies&lt;/span&gt;.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/subC.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by syntactically disallowing mismatched I/O and then synthesising process implementations automatically. Most choreography models assume that all communication occurs synchronously between two parties. This has been relaxed in some settings, allowing for example asynchronous communications, many-to-one, or one-to-many. However, these extensions are hardcoded in the syntax and semantics of each particular model.&lt;br /&gt;In this work, we present Cho-Reo-graphies (CR), a model where choreographies are parametric in the (Reo) connectors through which parties communicate. CR is the first choreography model where different communication semantics (e.g., synchronous and asynchronous) can freely be mixed in the same choreography. We prove that if a choreography respects the rules of the connectors that it uses, then the process implementation that we can synthesise from it enjoys deadlock freedom.</abstract>
		<bibitem>@unpublished{ACJM,
  author = {Arbab, Farhad and Cruz-Filipe, Lu{\'i}s and Jongmans, Sung-Shik and Montesi, Fabrizio},
  title = {Connectors Meet Choreographies},
  note = {submitted for publication}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Marco Carbone, Luís Cruz-Filipe, Fabrizio Montesi, &amp; Agata Murawska. &lt;span class=&quot;paper-title&quot;&gt;Multiparty Classical Choreographies&lt;/span&gt;.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/subG.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>We present Multiparty Classical Choreographies (MCC), a language model where global descriptions of communicating systems (choreographies) and processes can be modularly composed to implement typed multiparty sessions. Typing is achieved by generalising classical linear logic to judgements that explicitly record parallelism by means of hypersequents. Our approach unifies different lines of work on choreographies and processes with multiparty sessions, as well as their connection to linear logic. Thus, results developed in one context are carried over to the others. Key novelties of MCC include support for behavioural polymorphism in choreographies, as well as a translation from processes with replication to choreographies.</abstract>
		<bibitem>@unpublished{CCMM,
  author = {Carbone, Marco and Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio and Murawska, Agata},
  title = {Multiparty Classical Choreographies},
  note = {submitted for publication}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;A Core Model for Choreographic Programming&lt;/span&gt;.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/subH.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.&lt;br /&gt;In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.</abstract>
		<bibitem>@unpublished{CMa,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {A Core Model for Choreographic Programming},
  note = {submitted for publication}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;Procedural Choreographic Programming&lt;/span&gt;.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/subA.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is an emerging paradigm for correct-by-construction concurrent programming based on message passing. Models based on choreographic programming have been successfully developed for different settings where concurrent programming is challenging, including service-oriented computing and cyber-physical systems. However, the general applicability of the paradigm is limited by the current lack of support for reusable procedures, which hinders modularity.&lt;br /&gt;We propose Procedural Choreographies (PC), a choreographic language model with full procedural abstraction. PC includes unbounded process creation and name mobility, yielding a powerful framework for writing correct concurrent algorithms that can be compiled into a process calculus. This expressivity requires a typing discipline to ensure that processes are properly connected when enacting procedures. Connections may form networks of arbitrary graph structures. We develop a formal synthesis procedure that, given a program in PC, generates a correct-by-construction concurrent implementation in terms of a process calculus. We illustrate the expressivity of PC with a series of examples, including parallel streams and parallel computation based on pipelining.</abstract>
		<bibitem>@unpublished{CMb,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {Procedural Choreographic Programming},
  note = {submitted for publication}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Luís Cruz-Filipe, &amp; Fabrizio Montesi. &lt;span class=&quot;paper-title&quot;&gt;On Asynchrony and Choreographies&lt;/span&gt;.</content>
			
		<link>
			<name></name>
			<link>http://tinyurl.com/lcfilipe/pubs/subD.pdf</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Luís Cruz-Filipe</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically and then correct-by-construction implementations in process models are mechanically generated. The formal semantics of choreography languages are typically based on synchronous communications, in order to achieve a simpler theory. However, many real-world systems have asynchronous communications. Previous attempts at enriching choreographies with asynchrony rely on &lt;i&gt;ad-hoc&lt;/i&gt; constructions, whose adequacy is only argued informally.&lt;br /&gt;In this work, we present a systematic study of asynchronous communications in choreographies. First, we discuss and formalise the properties that an asynchronous semantics for choreographies should have. Then, we explore how out-of-order execution, previously used in choreographies for modelling concurrency, can be used to endow choreographies with an asynchronous semantics that satisfies our properties. Our development yields a pleasant correspondence with FIFO-based asynchronous messaging, modelled in a process calculus. Finally, we investigate the expressivity of choreography languages with respect to asynchrony. Specifically, we find out that choreography languages equipped with process spawning and name mobility primitives are expressive enough to program asynchronous behaviour over a simple synchronous semantics.</abstract>
		<bibitem>@unpublished{CMc,
  author = {Cruz-Filipe, Lu{\'i}s and Montesi, Fabrizio},
  title = {On Asynchrony and Choreographies},
  note = {submitted for publication}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Maurizio Gabbrielli, Saverio Giallorenzo, &amp; Fabrizio Montesi. (2015). &lt;span class=&quot;paper-title&quot;&gt;Applied Choreographies&lt;/span&gt;. CoRR, abs/1510.03637.</content>
			
		<link>
			<name>technical report</name>
			<link>http://arxiv.org/abs/1510.03637</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Saverio Giallorenzo</author>
			
		<author>Fabrizio Montesi</author>
			
		<abstract>Choreographic Programming is a methodology for the development of concurrent software based on a correctness-by-construction approach which, given a global description of a system (a choreography), automatically generates deadlock-free communicating programs via an EndPoint Projection (EPP). Previous works use target-languages for EPP that, like their source choreography languages, model communications using channel names (e.g., variants of CCS and π-calculus). This leaves a gap between such models and real-world implementations, where communications are concretely supported by low-level mechanisms for message routing. We bridge this gap by developing Applied Choreographies (AC), a new model for choreographic programming. AC brings the correctness-by-construction methodology of choreographies down to the level of a real executable language. The key feature of AC is that its semantics is based on message correlation --- a standard technique in Service-Oriented Computing --- while retaining the usual simple and intuitive syntax of choreography languages. We provide AC with a typing discipline that ensures the correct use of the low-level mechanism of message correlation, thus avoiding communication errors. We also define a two-step compilation from AC to a low-level Correlation Calculus, which is the basis of a real executable language (Jolie). Finally, we prove an operational correspondence theorem, which ensures that compiled programs behave as the original choreography. This is the first result of such correctness property in the case of a real-world implemented language.</abstract>
		<bibitem>@article{GGM15,
  author = {Gabbrielli, Maurizio and Giallorenzo, Saverio and Montesi, Fabrizio},
  title = {Applied Choreographies},
  journal = {CoRR},
  volume = {abs/1510.03637},
  year = {2015}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi, &amp; Marco Peressotti. (2017). &lt;span class=&quot;paper-title&quot;&gt;Choreographies meet Communication Failures&lt;/span&gt;. CoRR, abs/1712.05465.</content>
			
		<link>
			<name></name>
			<link>https://arxiv.org/abs/1803.01049</link>
		</link>
			
			
		<tag>Choreographic Programming</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<author>Marco Peressotti</author>
			
		<abstract>Choreographies are global descriptions of communication structures, inspired by the &quot;Alice and Bob&quot; notation of security protocols. They have been successfully employed in the design and implementation of distributed systems. However, there is still limited evidence of the applicability of choreographies in the real-world setting of distributed programming, where communication actions may fail. In this work, we propose the first choreography model that allows for communication failures and the programming of user-defined code to deal with such failures. We validate our model by implementing common strategies for handling communication failures in a robust way, which in turn can be used as a library by choreographies that assume reliable communication. We equip our model with a typing discipline that can statically verify reliability properties, in particular at-most-once and exactly-once delivery. We demonstrate the applicability of our model by defining a semantics-preserving compilation procedure towards a process calculus equipped with unreliable I/O actions.</abstract>
		<bibitem>@article{MP17,
  author = {Montesi, Fabrizio and Peressotti, Marco},
  title = {Choreographies meet Communication Failures},
  journal = {CoRR},
  volume = {abs/1712.05465},
  year = {2017},
  url = {http://arxiv.org/abs/1712.05465}
}
</bibitem>
	</paper>
			
		
			
	<paper>
		<content>Fabrizio Montesi, &amp; Marco Peressotti. (2018). &lt;span class=&quot;paper-title&quot;&gt;Classical Transitions&lt;/span&gt;. CoRR, abs/1803.01049.</content>
			
		<link>
			<name></name>
			<link>http://arxiv.org/abs/1803.01049</link>
		</link>
			
			
		<tag>Process Calculi</tag>
			
			
		<author>Fabrizio Montesi</author>
			
		<author>Marco Peressotti</author>
			
		<abstract>We introduce the calculus of Classical Transitions (CT), which extends the research line on the relationship between linear logic and processes to labelled transitions. The key twist from previous work is registering parallelism in typing judgements, by generalising linear logic judgements from one sequents to many (hypersequents). This allows us to bridge the gap between the structures of operators used as proof terms in previous work and those of the standard π-calculus (in particular parallel operator and restriction). The proof theory of CT allows for new proof transformations, which we show correspond to a labelled transition system (LTS) for processes. We prove that CT enjoys subject reduction and progress.</abstract>
		<bibitem>@article{MP18,
  author = {Montesi, Fabrizio and Peressotti, Marco},
  title = {Classical Transitions},
  journal = {CoRR},
  volume = {abs/1803.01049},
  year = {2018},
  url = {http://arxiv.org/abs/1803.01049}
}
</bibitem>
	</paper>
			
		
</collection>

</papers>
